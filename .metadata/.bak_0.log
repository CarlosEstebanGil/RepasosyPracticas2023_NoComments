!SESSION 2023-06-08 13:29:08.040 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-08 13:34:32.625
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 13:34:32.625
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7b8cb283,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38b54694,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 13:34:32.625
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7619fbe7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ead1b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-08 13:34:36.778
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 13:37:53.348
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 13:37:53.358
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-08 14:09:21.242
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:09:27.352
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:09:27.359
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:16.781
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:16.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:17.794
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:17.798
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:19.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:19.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:23:09.206
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:23:09.211
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:19.937
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:19.941
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:26.038
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:26.042
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:28.163
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:28.166
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:47:59.147
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:47:59.150
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-08 14:48:54.907 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-08 14:49:02.046
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 14:49:02.046
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c910acd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@612ac38b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 14:49:02.046
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9f2fe2e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4dd4965a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-08 14:49:08.214
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:49:19.501
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:49:19.513
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.core 4 4 2023-06-08 14:53:35.517
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Jse0001_varios_RepasosyPracticas2023 {

	public static void main(String[] args) {
	
		Jse0001_varios_RepasosyPracticas2023 appJse0001 = new Jse0001_varios_RepasosyPracticas2023();
		
		try {
			
			 appJse0001.conversionesTiposBasicas(); //(1)
			
			// appJse0001.polimorfismos(); //(2)
			
			// appJse0001.collections_1_basico(); //(3)
			
			// appJse0001.maps(); //(4)
			
			// appJse0001.trycathall(); //(5)
			
			//appJse0001.creandoApiClasesGenericsT(); //(6)
			
		    //appJse0001.collections_2_avanzado(); //(7)
		    
			// appJse0001.collections_3_avanzado(); //(8)
			
			// appJse0001.REGEXs(); //(9)
			
			// appJse0001.FilesJava7Avanzado(); //appJse0001.pruebatmp(); //.FilesJava7Avanzado(); //(10)
			
			// appJse0001.Hilos(); //(11)
			
			// Java 8:
			
			// appJse0001.exprsLambdas();  //(12)
			
			// Metodos por Defecto ( @Default )//(13) : es solo @Default arrib del met de una <<I>>. 
			
			// Interfaces funcionales ( @FunctionalInterface ) //(14)  Es solo anotar una IFunc(1 solo met no def a impl) x buena pracica safe code
			
			//appJse0001.referencias_a_Metodos(); // ( es el operador :: ) 
			// ( saber: x ahora los metodos referenciados (::) no aceptan parametros (xq java no impl 1 caracterist llamada currificacion xa poder)

			//appJse0001.Java8NewCollectionMethods(); // (16) Java 8 ForEach, RemoveIf, Sort
			
			//appJse0001.Java8_Streams(); // (17) STREAMS
			
			// appJse0001.Java8_Optional(); // (18) OPTIONAL<T>
			
			//appJse0001.Java8_Streams_Paralelos(); // (19) STREAMS ( PARALELOS )
			
			//appJse0001.Java8_MAP_Nueva_Funcionalidad(); // (20) API MAP NUEVA FUNCIONALIDAD  
			
			//appJse0001.Java8_LOCAL_DATE_TIME_NEW_API(); // (21) API NUEVA JAVA 8 PARA FECHAS Y HORAS
			
			//appJse0001.Java8_HIGHT_ORDER_FUNCTIONS(); // (22) HIGH ORDER FUNCTIONS
			
			//appJse0001.RX_2_Java(); // (23) RX JAVA PROGRAMACION ASYNCRONA // PUSH PARADIGMA REACTIVO FUNCIONAL
			
									// ( resu teoria y ejs de aca: https://blog.joda.org/2016/03/var-and-val-in-java.html )
			// appJse0001.Val_Var_Let_y_Auto_InferencedTypes(); 	//-> new: add de urgencia: esto va a aparecer x todos lados desde j8 o sup.. BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb|bbbbbbbbbbbbbbbbbbbbbbbb
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	/*	---------------------------------------------------------------------------------------------------
		(1)Conversiones basicas de Tipos de datos
		----------------------------------------------------------------------------------------------------*/
	
	public void conversionesTiposBasicas() {
		//1) int a String:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
			
			int iInt = 10; 
			String strInt = Integer.toString(iBIBIBBBBBBBBBBIBBBBBBBBBBBBBIBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBNBBBBBBBHBJBBBBBBBBBBBBBBV BBBBBBBBBBBBBBBNBBBBBBBBNBB BBBBBBBBBBBBBBBBB B B B B B B B B BB B B B B B B B B B BB B B B B B BBBBBBBBBBB-BBBBBBBBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB+B);
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-08 14:53:35.519
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-08 14:53:35.519
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-08 14:53:35.533
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Jse0001_varios_RepasosyPracticas2023 {

	public static void main(String[] args) {
	
		Jse0001_varios_RepasosyPracticas2023 appJse0001 = new Jse0001_varios_RepasosyPracticas2023();
		
		try {
			
			 appJse0001.conversionesTiposBasicas(); //(1)
			
			// appJse0001.polimorfismos(); //(2)
			
			// appJse0001.collections_1_basico(); //(3)
			
			// appJse0001.maps(); //(4)
			
			// appJse0001.trycathall(); //(5)
			
			//appJse0001.creandoApiClasesGenericsT(); //(6)
			
		    //appJse0001.collections_2_avanzado(); //(7)
		    
			// appJse0001.collections_3_avanzado(); //(8)
			
			// appJse0001.REGEXs(); //(9)
			
			// appJse0001.FilesJava7Avanzado(); //appJse0001.pruebatmp(); //.FilesJava7Avanzado(); //(10)
			
			// appJse0001.Hilos(); //(11)
			
			// Java 8:
			
			// appJse0001.exprsLambdas();  //(12)
			
			// Metodos por Defecto ( @Default )//(13) : es solo @Default arrib del met de una <<I>>. 
			
			// Interfaces funcionales ( @FunctionalInterface ) //(14)  Es solo anotar una IFunc(1 solo met no def a impl) x buena pracica safe code
			
			//appJse0001.referencias_a_Metodos(); // ( es el operador :: ) 
			// ( saber: x ahora los metodos referenciados (::) no aceptan parametros (xq java no impl 1 caracterist llamada currificacion xa poder)

			//appJse0001.Java8NewCollectionMethods(); // (16) Java 8 ForEach, RemoveIf, Sort
			
			//appJse0001.Java8_Streams(); // (17) STREAMS
			
			// appJse0001.Java8_Optional(); // (18) OPTIONAL<T>
			
			//appJse0001.Java8_Streams_Paralelos(); // (19) STREAMS ( PARALELOS )
			
			//appJse0001.Java8_MAP_Nueva_Funcionalidad(); // (20) API MAP NUEVA FUNCIONALIDAD  
			
			//appJse0001.Java8_LOCAL_DATE_TIME_NEW_API(); // (21) API NUEVA JAVA 8 PARA FECHAS Y HORAS
			
			//appJse0001.Java8_HIGHT_ORDER_FUNCTIONS(); // (22) HIGH ORDER FUNCTIONS
			
			//appJse0001.RX_2_Java(); // (23) RX JAVA PROGRAMACION ASYNCRONA // PUSH PARADIGMA REACTIVO FUNCIONAL
			
									// ( resu teoria y ejs de aca: https://blog.joda.org/2016/03/var-and-val-in-java.html )
			// appJse0001.Val_Var_Let_y_Auto_InferencedTypes(); 	//-> new: add de urgencia: esto va a aparecer x todos lados desde j8 o sup.. BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb|bbbbbbbbbbbbbbbbbbbbbbbb
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	/*	---------------------------------------------------------------------------------------------------
		(1)Conversiones basicas de Tipos de datos
		----------------------------------------------------------------------------------------------------*/
	
	public void conversionesTiposBasicas() {
		//1) int a String:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
			
			int iInt = 10; 
			String strInt = Integer.toString(iBIBIBBBBBBBBBBIBBBBBBBBBBBBBIBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBNBBBBBBBHBJBBBBBBBBBBBBBBV BBBBBBBBBBBBBBBNBBBBBBBBNBB BBBBBBBBBBBBBBBBB B B B B B B B B BB B B B B B B B B B BB B B B B B BBBBBBBBBBB-BBBBBBBBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB+B);
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-06-08 14:53:35.535
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-06-08 14:53:35.536
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-06-08 15:00:37.416 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-08 15:00:43.675
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 15:00:43.675
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4780341,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c910acd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 15:00:43.675
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@612ac38b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9f2fe2e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-08 15:00:49.009
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:16:54.346
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:16:54.362
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:32.860
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:32.868
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:42.232
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:42.237
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:38:39.219
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:38:39.223
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:01:07.661
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:01:07.667
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:26.781
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:26.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:40.962
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:40.965
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:44.717
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:44.723
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:19:18.937
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:19:18.939
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:29:41.692
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:29:41.696
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:30:19.507
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:30:19.511
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:37.236
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:37.239
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:59.059
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:59.062
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:36:11.158
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:36:11.161
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 19:19:08.544
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 19:19:08.549
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:46:51.825
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:46:51.835
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:47:01.120
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:47:01.123
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:07:40.826
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:07:40.828
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:18:27.425
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:18:27.428
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:24.950
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:24.954
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:30.481
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:30.484
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:20:02.412
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:20:02.416
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:23:45.192
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:23:45.196
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:24:20.668
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:24:20.671
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:37.358
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:37.361
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:55.310
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:55.314
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:35:10.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:35:10.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:37.701
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:37.708
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:47.311
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:47.314
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:46:29.653
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:46:29.656
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-09 12:45:05.905 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-09 12:45:12.638
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-09 12:45:12.638
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@578d472a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1191029d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-09 12:45:12.638
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54b2d002,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d1c63af,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-09 12:45:22.416
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:52:13.624
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:52:13.636
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:57:02.430
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:57:02.436
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:00.293
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:00.296
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:58.556
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:58.559
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:59:37.976
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:59:37.980
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:01.515
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:01.519
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:46.259
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:46.262
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.ui 2 0 2023-06-09 13:42:06.390
!MESSAGE The 'org.eclipse.jdt.ui.JavaAllCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.ClassCastException: class org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding cannot be cast to class org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding (org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding and org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @3741071d)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.computeExpectedTypes(CompletionEngine.java:4318)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2000)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2344)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:136)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:256)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:218)
	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:65)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:352)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:351)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:43:45.099
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:43:45.103
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:45:35.734
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:45:35.737
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:46:41.314
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:46:41.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:09.237
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:09.241
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:26.805
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:26.809
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:49:40.541
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:49:40.545
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:53:22.559
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:53:22.562
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:10:39.190
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:10:39.193
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:30.111
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:30.117
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:36.692
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:36.695
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:59.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:59.255
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:17:59.679
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:17:59.683
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:21:00.655
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:21:00.659
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:32:25.135
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:32:25.138
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:06.480
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:06.484
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:39.218
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:39.221
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:39:07.908
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:39:07.911
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:46:15.150
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:46:15.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:56:45.344
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:56:45.348
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:25.297
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:25.299
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:55.631
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:55.633
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:25:53.156
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:25:53.158
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:27:25.197
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:27:25.200
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:21.435
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:21.439
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:26.209
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:26.212
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:39:55.351
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:39:55.354
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:18.935
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:18.939
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:47.715
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:47.719
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:06.962
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:06.966
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:35.998
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:36.001
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:43:22.769
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:43:22.773
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:51:30.750
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:51:30.753
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:06.090
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:06.093
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:57.147
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:57.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:57:05.966
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:57:05.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:01.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:01.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:12.999
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:13.002
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:01:30.432
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:01:30.436
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:02:31.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:02:31.255
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:09.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:09.973
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:19.064
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:19.066
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:16:20.582
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:16:20.585
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:17:48.428
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:17:48.432
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:18:36.853
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:18:36.856
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:20:34.967
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:20:34.970
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:10.194
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:10.197
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:25.473
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:25.477
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:22:04.202
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:22:04.206
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:35.029
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:35.031
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:41.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:41.850
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:24:20.802
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:24:20.805
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:26:32.901
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:26:32.904
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:30:59.150
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:30:59.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:31:46.786
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:31:46.789
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:34:05.917
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:34:05.921
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:36:10.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:36:10.595
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:42:53.534
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:42:53.537
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:20.640
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:20.643
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:24.346
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:24.348
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:43.126
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:43.128
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:53.965
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:53.968
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:57.220
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:57.223
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:34:18.472
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:34:18.477
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:15.924
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:15.927
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:29.612
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:29.616
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:42.543
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:42.546
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:58.332
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:58.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:37:16.859
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:37:16.862
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:38:20.154
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:38:20.157
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:40:58.273
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:40:58.275
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:17.904
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:17.907
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:41.479
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:41.481
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:42:10.593
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:42:10.596
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:05.824
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:05.829
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:11.806
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:11.808
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:26.916
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:26.918
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:48:39.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:48:39.075
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:33.155
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:33.158
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:46.699
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:46.702
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:51:44.227
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:51:44.230
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-09 20:52:51.441
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:54:50.632
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:54:50.635
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:56:53.778
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:56:53.782
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:10.506
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:10.509
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:26.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:26.322
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:00:49.091
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:00:49.095
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:02:43.114
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:02:43.117
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:40.257
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:40.260
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:51.232
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:51.235
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:58.402
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:58.405
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:11.741
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:11.743
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:46.015
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:46.018
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:05:19.232
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:05:19.234
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:07:20.708
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:07:20.710
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:09:16.161
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:09:16.164
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:16:06.921
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:16:06.924
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-09 21:32:28.587
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:33:10.262
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:33:10.264
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:36:09.715
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:36:09.954
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:38:34.045
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:38:34.048
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:39:22.138
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:39:22.140
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:41.438
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:41.441
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:51.944
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:51.947
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:41:07.427
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:41:07.430
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:25.589
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:25.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:57.443
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:57.445
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:15:11.024
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:15:11.026
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:16:05.288
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:16:05.290
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:19:23.818
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:19:23.821
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:23:25.301
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:23:25.303
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:03.246
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:03.254
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:05.317
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:05.322
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:30.600
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:30.602
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:27.312
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:27.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:47.379
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:47.381
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:40:07.825
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:40:07.828
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:10.171
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:10.174
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:31.478
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:31.482
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:42:32.833
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:42:32.836
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-09 22:42:59.785
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:06.070
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:06.076
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:28.068
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:28.071
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:44:08.414
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:44:08.424
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:49:26.087
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:49:26.107
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:09.913
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:09.915
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:19.839
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:19.842
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:09.382
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:09.385
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:54.568
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:54.570
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:58:24.953
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:58:24.957
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:07:54.704
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:07:54.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:52:13.036
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:52:13.039
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:58:48.461
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:58:48.463
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:59:23.900
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:59:23.903
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:00.282
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:00.284
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:05.152
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:05.154
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:03:06.742
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:03:06.745
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:20.590
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:20.603
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:24.621
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:24.625
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:46:04.256
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:46:04.258
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 13:29:01.224
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 13:29:01.226
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 14:58:20.494
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 14:58:20.498
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:28:30.694
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:28:30.700
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:42:12.143
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:42:12.145
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:59:40.746
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:59:40.751
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:49:02.788
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:49:02.791
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:57:08.876
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:57:08.881
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:36:33.322
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:36:33.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:40:40.032
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:40:40.035
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:50:09.741
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:50:09.747
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 00:12:22.977
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 00:12:23.007
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-13 14:42:00.068 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-13 14:42:06.548
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-13 14:42:06.548
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@268f0ff3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11978f52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-13 14:42:06.548
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e0855b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@484b5a21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-13 14:42:13.498
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 16:28:24.510
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 16:28:24.529
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-14 11:47:37.634 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-14 11:47:52.131
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-14 11:47:52.131
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@484b5a21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16e5344c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-14 11:47:52.131
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-14 11:47:59.957
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:56:14.542
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:56:14.577
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:57:33.028
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:57:33.035
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:58:35.853
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:58:35.857
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:14:35.906
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:14:35.912
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:20:37.718
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:20:37.722
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:11:58.905
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:11:58.912
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:13:22.658
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:13:22.662
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 16:52:48.311
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 16:52:48.317
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:14:12.233
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:14:12.243
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:23:00.168
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:23:00.173
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:47:06.760
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:47:06.765
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-16 13:32:12.987 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-16 13:32:32.359
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-16 13:32:32.359
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16e5344c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-16 13:32:32.359
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55746340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-16 13:32:42.889
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-22 13:45:30.198
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-22 13:45:30.227
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-23 10:35:10.686 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-23 10:35:20.242
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-23 10:35:20.242
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16e5344c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-23 10:35:20.242
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55746340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-23 10:35:27.630
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 10:55:25.937
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 10:55:25.956
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 19:38:53.377
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 19:38:53.402
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:53:58.274
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:53:58.285
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:55:21.899
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:55:21.903
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:09:28.279
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:09:28.287
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:22:43.916
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:22:43.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:24.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:24.166
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:27.832
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:27.848
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:51:07.288
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:51:07.291
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:57:25.991
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:57:26.002
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:04:44.098
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:04:44.112
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:07:09.491
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:07:09.495
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:39:27.237
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:39:27.246
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.947
!MESSAGE Failed to stream using org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport@10d14d47 - falling back to org.eclipse.epp.internal.mpc.core.util.TransportFactory$$Lambda$1679/0x0000000801c21d88@72f9a529: Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 1
org.eclipse.core.runtime.CoreException: Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:112)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: javax.net.ssl.SSLException: Connection reset
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:127)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:369)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:307)
	at java.base/sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1689)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1063)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	... 3 more
	Suppressed: java.net.SocketException: Connection reset by peer
		at java.base/sun.nio.ch.NioSocketImpl.implWrite(NioSocketImpl.java:420)
		at java.base/sun.nio.ch.NioSocketImpl.write(NioSocketImpl.java:440)
		at java.base/sun.nio.ch.NioSocketImpl$2.write(NioSocketImpl.java:826)
		at java.base/java.net.Socket$SocketOutputStream.write(Socket.java:1045)
		at java.base/sun.security.ssl.SSLSocketOutputRecord.encodeAlert(SSLSocketOutputRecord.java:82)
		at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:400)
		... 39 more
Caused by: java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	... 35 more
Contains: Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.950
!MESSAGE Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
javax.net.ssl.SSLException: Connection reset
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:127)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:369)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:307)
	at java.base/sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1689)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1063)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
	Suppressed: java.net.SocketException: Connection reset by peer
		at java.base/sun.nio.ch.NioSocketImpl.implWrite(NioSocketImpl.java:420)
		at java.base/sun.nio.ch.NioSocketImpl.write(NioSocketImpl.java:440)
		at java.base/sun.nio.ch.NioSocketImpl$2.write(NioSocketImpl.java:826)
		at java.base/java.net.Socket$SocketOutputStream.write(Socket.java:1045)
		at java.base/sun.security.ssl.SSLSocketOutputRecord.encodeAlert(SSLSocketOutputRecord.java:82)
		at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:400)
		... 39 more
Caused by: java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	... 35 more
!SUBENTRY 2 org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.951
!MESSAGE Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.951
!MESSAGE Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.epp.mpc.ui 2 0 2023-06-24 17:49:00.954
!MESSAGE Failed to download resource for entry 'Jeeeyul's Eclipse Themes 2.3' (339851) from https://marketplace.eclipse.org/sites/all/themes/solstice/public/images/marketplace/default.png
!STACK 0
java.io.IOException: Pipe closed
	at java.base/java.io.PipedInputStream.read(PipedInputStream.java:307)
	at java.base/java.io.PipedInputStream.read(PipedInputStream.java:377)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader$1.read(FileReader.java:334)
	at java.base/java.io.BufferedInputStream.fill(BufferedInputStream.java:244)
	at java.base/java.io.BufferedInputStream.read1(BufferedInputStream.java:284)
	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:343)
	at java.base/java.io.BufferedInputStream.fill(BufferedInputStream.java:244)
	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:263)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$ResourceFuture.lambda$0(ResourceProvider.java:95)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$ResourceFuture.retrieve(ResourceProvider.java:149)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:309)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-06-24 17:50:50.052
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:459)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	... 34 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-06-24 17:50:50.053
!MESSAGE Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
!STACK 1
org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
!SUBENTRY 2 unknown 8 1 2023-06-24 17:50:50.053
!MESSAGE 

!ENTRY org.eclipse.epp.mpc.ui 1 2 2023-06-24 17:50:50.057
!MESSAGE Skipping update check for repository 'https://download.eclipse.org/buildship/updates/e410/releases/3.x' - failed to read repository. Affected entries: 
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x.
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:190)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:459)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	... 19 more
Caused by: org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	... 34 more
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1002 2023-06-24 17:50:50.057
!MESSAGE Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x.
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:459)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	... 34 more
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-06-24 17:50:50.057
!MESSAGE Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
!STACK 1
org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
!SUBENTRY 3 unknown 8 1 2023-06-24 17:50:50.057
!MESSAGE 
!SUBENTRY 1 org.eclipse.epp.mpc.ui 1 0 2023-06-24 17:50:50.057
!MESSAGE Buildship Gradle Integration 3.0

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:54:39.943
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:54:39.945
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:03:53.843
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:03:53.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:20:29.039
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:20:29.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:07:20.842
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:07:20.866
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:19:47.409
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:19:47.415
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:23:34.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:23:34.321
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-24 19:23:48.427 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-24 19:23:55.280
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-24 19:23:55.280
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f1ad846,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d5ae6aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-24 19:23:55.280
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc2e022,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2210e466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-24 19:24:02.262
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:38:11.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:38:11.347
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:43:38.983
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:43:38.990
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:57:59.699
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:57:59.703
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:58:24.744
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:58:24.748
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:04:21.638
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:04:21.641
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:06:45.046
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:06:45.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:08:42.720
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:08:42.724
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:21.907
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:21.913
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:37.750
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:37.753
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:15:57.542
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:15:57.545
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:18:11.329
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:18:11.332
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-06 14:32:07.450 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-06 14:32:14.032
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-06 14:32:14.032
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-06 14:32:14.032
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55746340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a0c7af6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-06 14:32:20.460
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:29:59.929
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:29:59.944
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:33:33.480
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:33:33.489
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:42:49.551
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:42:49.556
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:44:32.657
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:44:32.660
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:54:26.414
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:54:26.418
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:26.117
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:26.121
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:41.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:41.709
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:02:15.885
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:02:15.890
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:03:05.488
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:03:05.491
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:10:35.112
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:10:35.115
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:10.503
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:10.506
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:32.849
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:32.852
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:12:43.967
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:12:43.970
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:45:07.434
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:45:07.444
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:57:30.876
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:57:30.886
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:58:25.675
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:58:25.682
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:09:45.563
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:09:45.567
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:11:54.664
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:11:54.667
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:13:28.167
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:13:28.170
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:14:54.844
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:14:54.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:19:12.498
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:19:12.501
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:31:12.511
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:31:12.523
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:44:17.009
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:44:17.022
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:49:49.259
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:49:49.262
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:27:09.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:27:09.058
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:36:08.688
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:36:08.693
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:06.094
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:06.096
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:57.363
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:57.367
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:54:51.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:54:51.710
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:56:52.514
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:56:52.518
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:32.088
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:32.091
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:57.643
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:57.646
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:59:16.799
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:59:16.802
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:02:15.224
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:02:15.226
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:04:05.949
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:04:05.952
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:07:01.290
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:07:01.293
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:02.657
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:02.661
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:32.385
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:32.388
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:26.834
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:26.839
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:39.332
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:39.335
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:28:15.066
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:28:15.069
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:30:19.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:30:19.849
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:59:17.776
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:59:17.780
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 20:00:01.987
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 20:00:01.990
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:38.941
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:38.950
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:54.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:54.972
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:26:30.000
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:26:30.003
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:38.012
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:38.017
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:48.156
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:48.161
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:29:12.721
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:29:12.724
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:03.665
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:03.668
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:21.338
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:21.339
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:41.300
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:41.303
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:31:11.383
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:31:11.385
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:34:09.097
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:34:09.100
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:35:49.003
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:35:49.005
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:36:15.139
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:36:15.144
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:16.281
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:16.283
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:38.565
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:38.571
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:21.676
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:21.687
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:41.178
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:41.182
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:47:37.324
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:47:37.329
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:50:20.948
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:50:20.951
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:14:51.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:14:51.261
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:07.266
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:07.271
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:13.103
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:13.108
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:33.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:33.257
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:08.136
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:08.139
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:36.111
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:36.114
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:43.079
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:43.082
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:52.574
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:52.579
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:08.901
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:08.905
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:36.047
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:36.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:52.597
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:52.599
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:21:02.981
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:21:02.984
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:18.951
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:18.954
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:22.268
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:22.271
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:25.127
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:25.129
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 01:22:51.214
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 01:22:51.218
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-07 15:16:06.676 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-07-07 15:17:02.903
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-07-07 15:17:05.780
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-07 15:17:05.781
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0b0bd9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6150afc6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-07 15:17:05.781
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49f50c8f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46e6458d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-07 15:17:11.840
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:17:13.608
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:17:13.620
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:29:53.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:29:53.264
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:40:16.991
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:40:16.996
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:42:00.947
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:42:00.951
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:44:33.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:44:33.787
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:47:14.694
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:47:14.699
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:11.345
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:11.349
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:20.340
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:20.345
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:56:02.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:56:02.069
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:02.667
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:02.671
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:24.832
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:24.835
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:10:40.356
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:10:40.360
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:33.566
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:33.569
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:43.215
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:43.218
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:41.744
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:41.748
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:57.002
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:57.007
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:38:00.429
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:38:00.432
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:45:16.642
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:45:16.646
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:48:37.074
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:48:37.078
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 20:54:43.437
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 20:54:43.451
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:05:11.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:05:11.718
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:17:58.851
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:17:58.859
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:18:33.558
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:18:33.561
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:19:55.598
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:19:55.601
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:20:56.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:20:56.929
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:21:57.417
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:21:57.420
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:13.914
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:13.917
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:54.943
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:54.945
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:25:09.717
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:25:09.721
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:30:59.216
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:30:59.219
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:11.826
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:11.829
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:41.700
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:41.703
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:56.468
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:56.470
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:36:15.603
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:36:15.605
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:46:06.306
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:46:06.317
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:08:03.076
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:08:03.084
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:16:31.472
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:16:31.475
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:21:03.245
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:21:03.247
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:28:56.011
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:28:56.015
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:38:40.466
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:38:40.475
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:39:46.330
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:39:46.333
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:40:20.595
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:40:20.598
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:50:49.124
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:50:49.130
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:53:16.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:53:16.069
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:56:54.723
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:56:54.725
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:58:01.173
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:58:01.176
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:59:09.065
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:59:09.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:36.906
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:36.910
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:46.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:46.787
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:03:57.814
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:03:57.817
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:04:02.231
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:04:02.234
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:05:26.078
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:05:26.080
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:07:13.643
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:07:13.645
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:08:14.717
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:08:14.719
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:25.263
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:25.266
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:31.777
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:31.779
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:11.625
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:11.628
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:30.142
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:30.145
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:50.368
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:50.371
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:18.764
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:18.766
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:22.344
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:22.347
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:30.820
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:30.823
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:15:05.452
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:15:05.454
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:16:26.112
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:16:26.115
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:00.282
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:00.285
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:45.685
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:45.688
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:19:30.924
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:19:30.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:20:19.800
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:20:19.802
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:22:00.514
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:22:00.517
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-13 11:30:25.826 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-13 11:30:35.242
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-13 11:30:35.242
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@257b3561,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78861d9e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-13 11:30:35.242
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a878778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-13 11:30:43.922
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:31:52.739
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:31:52.752
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:32:59.919
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:32:59.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:33:10.554
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:33:10.558
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:48:48.429
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:48:48.433
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:47:13.204
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:47:13.211
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:56:26.606
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:56:26.609
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:15:51.661
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:15:51.666
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:49.185
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:23:49.189
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:23:49.189
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:49.405
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:23:49.406
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:23:49.407
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:49.431
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:23:49.432
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:23:49.433
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:50.359
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:23:50.360
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:23:50.361
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:07.627
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:24:07.628
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:24:07.629
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:07.648
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:07.650
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:07.650
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:08.649
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:24:08.650
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:24:08.650
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:11.664
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:11.665
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:11.666
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:12.251
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:12.252
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:12.252
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:12.624
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se vé.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerré codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **vá (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEÑAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqué el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: menú: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqué el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto está en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una acá.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamaño fijo que se establece al momento de su creación. Si defines un arreglo de tipo char de tamaño 2, 
		//		no puedes agregar automáticamente un nuevo elemento más allá de ese tamaño sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendrías q crear un nuevo arreglo c/un > tamaño y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementación de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se vé h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitaré referenciar indices concretos ent necesitaré llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente sé la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection – 
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0 ó <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no está pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parámetros de métodos se pasan por valor. Cuando pasas una lista como parámetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en sí. Esto significa que el método 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El método Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el método compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresión lambda, estás intentando usar una comparación VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresión lambda, utilizamos el método compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparación y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debería ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sería otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecución de un bucle de manera prematura, incluso si la condición del 
									*	bucle aún no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	práctica menos común y generalmente se recomienda evitarlo cuando sea posible.
										
										Aquí hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del código: El uso de break puede dificultar la lectura y comprensión del código,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel código sea más difícil de mantener y depurar.
										
										Diseño estructurado: El uso de break puede romper el principio de diseño estructurado, que busca reducir la complejidad y mejorar 
										la claridad del código. Al utilizar break, se interrumpe la ejecución normal del bucle y se puede perder la estructura lógica y la 
										coherencia del código.
										
										Alternativas más claras: En muchos casos, se pueden utilizar otras técnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condición del bucle o utilizando una instrucción return para salir de un método si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminación temprana en casos excepcionales, se recomienda utilizarlo con moderación y asegurarse de qsea la mejor opción en 
										términos de legibilidad y mantenibilidad del código.
										
										En general, es recomendable seguir las mejores prácticas de programación y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas más claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibujé + pensé! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerré codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo después de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el código es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces sí hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1. Después se incrementa esta variable en 1. Véase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Véase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Véase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evalúa la expresión y después se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresión sin evaluar y después se evalúa.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripción del primer parámetro.
		* @param parametro2 Descripción del segundo parámetro.
		* @return Descripción del valor de retorno.
		* @throws ExcepcionTipo Descripción de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no está definida en la biblioteca estándar de Java!!!!!!!!! 
			. En realidad, la implementación de una lista simplemente enlazada, incluyendo la definición de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versión de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberías usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cómo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una colección de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan métodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una colección de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripción del primer parámetro.
	* @param parametro2 Descripción del segundo parámetro.
	* @return Descripción del valor de retorno.
	* @throws ExcepcionTipo Descripción de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems será =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent será la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamaño

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamañoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamañoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un método. Esto significa que cuando pasas un array 
		//				como argumento a un método, estás pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el método que recibe el array puede modificar su contenido y esos cambios se reflejarán 
		//				en el array original fuera del método. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al menú "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categoría "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrón"), ingresa el comentario personalizado que deseas insertar. Puedes incluir información dinámica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaña "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cuándo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de código.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusión. Parece que hay una confusión en la terminología. La opción "Insert Template" no está disponible directamente en Eclipse sin complementos adicionales. Lamento la información incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al menú "Window" (Ventana) en la barra de navegación superior.
			Selecciona "Preferences" (Preferencias) en el menú desplegable. Esto abrirá la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categoría "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecerá una lista de plantillas de código existentes. Haz clic en el botón "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrón), escribe el código de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla más flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinación de teclas "Ctrl + Espacio" para activar la función de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el código.
			No hay una opción de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rápidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto está en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1798)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5155)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4778)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5034)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:12.626
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1798)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5155)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4778)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5034)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:12.627
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1798)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5155)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4778)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5034)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 13:26:58.330
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:26:58.333
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:26:58.338
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 14:26:07.826
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 14:26:07.849
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 14:26:07.853
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:00:07.564
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:00:07.570
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:00:07.573
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:02:08.922
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:02:08.925
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:02:08.928
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:03:38.995
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:03:38.998
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:03:39.000
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:52:24.562
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:52:24.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:52:24.598
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:53:18.840
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:18.842
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:18.844
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:53:56.862
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:56.865
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:56.868
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 16:02:44.036
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:02:44.046
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:02:44.051
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 16:05:10.531
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:05:10.534
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:05:10.537
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-24 18:45:20.275 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-24 18:45:29.750
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-24 18:45:29.750
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6207145c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-24 18:45:29.750
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a259f6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ccf6114,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-24 18:45:36.321
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:08:24.875
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:08:24.889
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:09:23.362
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:09:23.370
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:11.023
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:11.027
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:22.774
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:22.779
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:47.510
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:47.513
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:13:59.776
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:13:59.780
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:14:20.892
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:14:20.896
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:33:07.864
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:33:07.868
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:47:53.963
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:47:53.966
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:48:29.022
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:48:29.025
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 21:46:32.660
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 21:46:32.664
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 14:26:25.538
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 14:26:25.546
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 17:05:30.704
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 17:05:30.718
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-27 15:05:59.405 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-27 15:07:09.711
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-27 15:07:09.711
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a878778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-27 15:07:09.711
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6207145c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a259f6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-27 15:07:19.798
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-27 21:45:28.400
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-27 21:45:28.440
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-08-03 20:14:55.528 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-03 20:15:03.601
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-03 20:15:03.601
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a878778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-03 20:15:03.601
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6207145c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a259f6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-03 20:15:13.252
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:17.404
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:18.606
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:19.050
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-03 20:16:20.885
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.loadMetadataRepository(ProvisioningContext.java:233)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedMetadataRepositories(ProvisioningContext.java:211)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getMetadata(ProvisioningContext.java:299)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.gatherAvailableInstallableUnits(SimplePlanner.java:357)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getSolutionFor(SimplePlanner.java:434)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getProvisioningPlan(SimplePlanner.java:520)
	at org.eclipse.equinox.internal.p2.operations.PlannerResolutionJob.runModal(PlannerResolutionJob.java:80)
	at org.eclipse.equinox.p2.operations.ProfileChangeOperation.resolveModal(ProfileChangeOperation.java:118)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveModal(ProfileChangeOperationComputer.java:367)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolve(ProfileChangeOperationComputer.java:356)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveInstall(ProfileChangeOperationComputer.java:282)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.run(ProfileChangeOperationComputer.java:180)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1000 2023-08-03 20:16:20.886
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:20.889
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:31.746
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/content.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:00.462
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:01.673
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:01.975
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-03 20:17:04.129
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.load(CompositeArtifactRepository.java:496)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.addChild(CompositeArtifactRepository.java:177)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.<init>(CompositeArtifactRepository.java:99)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory.load(CompositeArtifactRepositoryFactory.java:120)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedRepository(ProvisioningContext.java:189)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedArtifactRepositories(ProvisioningContext.java:163)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getArtifactRepositories(ProvisioningContext.java:149)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.getArtifactRepositories(DownloadManager.java:110)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:95)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1000 2023-08-03 20:17:04.129
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:04.130
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:14.044
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/artifacts.xml.xz

!ENTRY org.eclipse.equinox.p2.engine 4 4 2023-08-03 20:17:36.105
!MESSAGE An error occurred while collecting items to be installed
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2023-08-03 20:17:36.105
!MESSAGE session context was:(profile=C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse, phase=org.eclipse.equinox.internal.p2.engine.phases.Collect, operand=, action=).
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2023-08-03 20:17:36.105
!MESSAGE Cannot invoke "org.eclipse.equinox.internal.p2.repository.Transport.download(java.net.URI, java.io.OutputStream, org.eclipse.core.runtime.IProgressMonitor)" because the return value of "org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getTransport()" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.equinox.internal.p2.repository.Transport.download(java.net.URI, java.io.OutputStream, org.eclipse.core.runtime.IProgressMonitor)" because the return value of "org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getTransport()" is null
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:748)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:672)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifacts(SimpleArtifactRepository.java:864)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.getArtifacts(CompositeArtifactRepository.java:362)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.fetch(DownloadManager.java:127)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:98)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-08-17 13:00:09.972 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-17 13:00:18.517
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:00:18.517
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c83ed77,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d271a54,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:00:18.517
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ff8e744,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@409395b9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-17 13:00:26.607
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:03:51.492
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at java.base/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:45)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:194)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:03:51.495
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:35)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:194)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:03:51.496
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:35)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:194)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:36.117
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:37.328
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:37.632
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:04:39.775
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.loadMetadataRepository(ProvisioningContext.java:233)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedMetadataRepositories(ProvisioningContext.java:211)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getMetadata(ProvisioningContext.java:299)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.gatherAvailableInstallableUnits(SimplePlanner.java:357)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getSolutionFor(SimplePlanner.java:434)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getProvisioningPlan(SimplePlanner.java:520)
	at org.eclipse.equinox.internal.p2.operations.PlannerResolutionJob.runModal(PlannerResolutionJob.java:80)
	at org.eclipse.equinox.p2.operations.ProfileChangeOperation.resolveModal(ProfileChangeOperation.java:118)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveModal(ProfileChangeOperationComputer.java:367)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolve(ProfileChangeOperationComputer.java:356)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveInstall(ProfileChangeOperationComputer.java:282)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.run(ProfileChangeOperationComputer.java:180)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1000 2023-08-17 13:04:39.776
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:39.778
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:47.891
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/content.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:22.947
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:24.004
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:24.317
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:05:26.532
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.load(CompositeArtifactRepository.java:496)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.addChild(CompositeArtifactRepository.java:177)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.<init>(CompositeArtifactRepository.java:99)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory.load(CompositeArtifactRepositoryFactory.java:120)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedRepository(ProvisioningContext.java:189)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedArtifactRepositories(ProvisioningContext.java:163)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getArtifactRepositories(ProvisioningContext.java:149)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.getArtifactRepositories(DownloadManager.java:110)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:95)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1000 2023-08-17 13:05:26.533
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:26.534
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:33.603
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/artifacts.xml.xz

!ENTRY org.eclipse.equinox.preferences 4 4 2023-08-17 13:05:55.154
!MESSAGE Exception saving preferences to: C:/Users/carlo/.p2/org.eclipse.equinox.p2.engine/profileRegistry/C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile/.data/.settings/org.eclipse.equinox.p2.artifact.repository.prefs.
!STACK 0
java.nio.file.NoSuchFileException: C:\Users\carlo\.p2\org.eclipse.equinox.p2.engine\profileRegistry\C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile\.data\.settings\org.eclipse.equinox.p2.artifact.repository.prefs.bak
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileCopy.move(WindowsFileCopy.java:326)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.move(WindowsFileSystemProvider.java:293)
	at java.base/java.nio.file.Files.move(Files.java:1426)
	at org.eclipse.core.internal.preferences.EclipsePreferences.write(EclipsePreferences.java:289)
	at org.eclipse.core.internal.preferences.EclipsePreferences.save(EclipsePreferences.java:1066)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences.doSave(ProfilePreferences.java:141)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences$SaveJob.run(ProfilePreferences.java:54)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.engine 2 0 2023-08-17 13:05:55.155
!MESSAGE Exception saving profile preferences
!STACK 0
org.osgi.service.prefs.BackingStoreException: Exception saving preferences to: C:/Users/carlo/.p2/org.eclipse.equinox.p2.engine/profileRegistry/C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile/.data/.settings/org.eclipse.equinox.p2.artifact.repository.prefs.
	at org.eclipse.core.internal.preferences.EclipsePreferences.write(EclipsePreferences.java:296)
	at org.eclipse.core.internal.preferences.EclipsePreferences.save(EclipsePreferences.java:1066)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences.doSave(ProfilePreferences.java:141)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences$SaveJob.run(ProfilePreferences.java:54)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.nio.file.NoSuchFileException: C:\Users\carlo\.p2\org.eclipse.equinox.p2.engine\profileRegistry\C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile\.data\.settings\org.eclipse.equinox.p2.artifact.repository.prefs.bak
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileCopy.move(WindowsFileCopy.java:326)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.move(WindowsFileSystemProvider.java:293)
	at java.base/java.nio.file.Files.move(Files.java:1426)
	at org.eclipse.core.internal.preferences.EclipsePreferences.write(EclipsePreferences.java:289)
	... 4 more
!SESSION 2023-08-17 13:06:18.265 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.tm.terminal.connector.local 4 0 2023-08-17 13:06:23.734
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.local [336]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
              org.eclipse.tm.terminal.view.core [509]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.connector.process; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.connector.process; bundle-version="4.8.100.202204200013"; singleton:="true"
       org.eclipse.tm.terminal.connector.process [337]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.connector.process 4 0 2023-08-17 13:06:23.738
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.process [337]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
              org.eclipse.tm.terminal.view.core [509]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.connector.ssh 4 0 2023-08-17 13:06:23.739
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.ssh [338]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.connector.telnet 4 0 2023-08-17 13:06:23.742
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.telnet [339]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2023-08-17 13:06:23.782
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.wildwebdeveloper.xml [376]
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.languageconfiguration; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.languageconfiguration; bundle-version="0.5.5.202305171341"; singleton:="true"
       org.eclipse.tm4e.languageconfiguration [512]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.4"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.ui; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.ui; bundle-version="0.6.4.202305161247"; singleton:="true"
       org.eclipse.tm4e.ui [514]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry; bundle-version="0.3.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient5 4 0 2023-08-17 13:06:23.786
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient5 [498]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient5.win32 4 0 2023-08-17 13:06:23.790
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient5.win32 [499]
  Unresolved requirement: Import-Package: org.eclipse.ecf.provider.filetransfer.httpclient5; version="[1.0.0,2.0.0)"
    -> Export-Package: org.eclipse.ecf.provider.filetransfer.httpclient5; bundle-symbolic-name="org.eclipse.ecf.provider.filetransfer.httpclient5"; bundle-version="1.1.0.v20230423-0417"; version="1.0.0"
       org.eclipse.ecf.provider.filetransfer.httpclient5 [498]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Import-Package: org.eclipse.ecf.internal.provider.filetransfer.httpclient5; version="[1.0.0,2.0.0)"
    -> Export-Package: org.eclipse.ecf.internal.provider.filetransfer.httpclient5; bundle-symbolic-name="org.eclipse.ecf.provider.filetransfer.httpclient5"; bundle-version="1.1.0.v20230423-0417"; version="1.0.0"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.linuxtools.docker.core 4 0 2023-08-17 13:06:23.792
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.linuxtools.docker.core [502]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.0.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.linuxtools.docker.editor.ls 4 0 2023-08-17 13:06:23.794
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.linuxtools.docker.editor.ls [504]
  Unresolved requirement: Require-Bundle: org.eclipse.wildwebdeveloper.embedder.node
    -> Bundle-SymbolicName: org.eclipse.wildwebdeveloper.embedder.node; bundle-version="1.0.2.202212140804"
       org.eclipse.wildwebdeveloper.embedder.node [515]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.ui; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.ui; bundle-version="0.6.4.202305161247"; singleton:="true"
       org.eclipse.tm4e.ui [514]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.linuxtools.docker.ui 4 0 2023-08-17 13:06:23.800
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.linuxtools.docker.ui [505]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.0.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.linuxtools.docker.core; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.linuxtools.docker.core; bundle-version="5.7.0.202206072042"; singleton:="true"
       org.eclipse.linuxtools.docker.core [502]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.0.0"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.control 4 0 2023-08-17 13:06:23.801
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.control [508]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.view.core 4 0 2023-08-17 13:06:23.802
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.view.core [509]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.view.ui 4 0 2023-08-17 13:06:23.815
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.view.ui [510]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="[5.2.0,6.0.0)"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.core 4 0 2023-08-17 13:06:23.816
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.core [511]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.languageconfiguration 4 0 2023-08-17 13:06:23.817
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.languageconfiguration [512]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.4"
    -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.ui; bundle-version="0.6.4"
    -> Bundle-SymbolicName: org.eclipse.tm4e.ui; bundle-version="0.6.4.202305161247"; singleton:="true"
       org.eclipse.tm4e.ui [514]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.registry 4 0 2023-08-17 13:06:23.818
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.registry [513]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
    -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
       org.eclipse.tm4e.core [511]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.ui 4 0 2023-08-17 13:06:23.819
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.ui [514]
  Unresolved requirement: Require-Bundle: org.eclipse.ui.trace; resolution:="optional"
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry; bundle-version="0.6.3"
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
    -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.wildwebdeveloper.embedder.node 4 0 2023-08-17 13:06:23.819
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.wildwebdeveloper.embedder.node [515]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2023-08-17 13:06:32.635
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:06:32.635
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@195cbf5e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cb82b09,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:06:32.635
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49665f92,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@b68932b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-17 13:06:40.728
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2023-08-17 13:06:40.785
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.tm.terminal.view.ui.TerminalsView" id and the "Terminal" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2023-08-17 13:06:40.786
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.tcf.te.ui.terminals.TerminalsView" id and the "Terminals (Old)" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:07:28.048
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at java.base/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:45)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:231)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:07:28.050
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:35)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:231)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:07:28.053
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at java.base/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:45)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:231)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:09:04.918
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:09:05.529
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:249)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.loadMetadataRepository(ProvisioningContext.java:233)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedMetadataRepositories(ProvisioningContext.java:211)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getMetadata(ProvisioningContext.java:299)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.updatesFor(SimplePlanner.java:1005)
	at org.eclipse.equinox.p2.operations.UpdateOperation.updatesFor(UpdateOperation.java:144)
	at org.eclipse.equinox.p2.operations.UpdateOperation.computeProfileChangeRequest(UpdateOperation.java:180)
	at org.eclipse.equinox.p2.operations.UpdateOperation.lambda$0(UpdateOperation.java:315)
	at org.eclipse.equinox.internal.p2.operations.SearchForUpdatesResolutionJob.runModal(SearchForUpdatesResolutionJob.java:41)
	at org.eclipse.equinox.p2.operations.ProfileChangeOperation.resolveModal(ProfileChangeOperation.java:118)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveModal(ProfileChangeOperationComputer.java:367)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolve(ProfileChangeOperationComputer.java:356)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveUpdate(ProfileChangeOperationComputer.java:292)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.run(ProfileChangeOperationComputer.java:183)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Caused by: org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:09:05.530
!MESSAGE HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml
!STACK 1
org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:09:05.530
!MESSAGE General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:09:05.532
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:09:14.461
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/content.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:10:08.840
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/artifacts.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:10:22.382
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:10:22.984
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:249)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory.getLocalFile(SimpleArtifactRepositoryFactory.java:68)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory.load(SimpleArtifactRepositoryFactory.java:92)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory.load(SimpleArtifactRepositoryFactory.java:80)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.load(CompositeArtifactRepository.java:496)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.addChild(CompositeArtifactRepository.java:177)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.<init>(CompositeArtifactRepository.java:99)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory.load(CompositeArtifactRepositoryFactory.java:120)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedRepository(ProvisioningContext.java:189)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedArtifactRepositories(ProvisioningContext.java:163)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getArtifactRepositories(ProvisioningContext.java:149)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.getArtifactRepositories(DownloadManager.java:110)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:95)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	... 1 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:10:22.984
!MESSAGE HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml
!STACK 1
org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:10:22.984
!MESSAGE General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:10:22.985
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.artifact.repository 4 0 2023-08-17 13:10:26.587
!MESSAGE Error processing mirrors URL: http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.core.runtime.CoreException: HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:190)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	... 16 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:10:26.588
!MESSAGE HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:10:26.588
!MESSAGE General connection error with response code=301

!ENTRY org.eclipse.equinox.p2.artifact.repository 4 0 2023-08-17 13:10:26.950
!MESSAGE Error processing mirrors URL: http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.core.runtime.CoreException: HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:190)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	... 16 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:10:26.950
!MESSAGE HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:10:26.950
!MESSAGE General connection error with response code=301
