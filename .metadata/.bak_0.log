!SESSION 2023-06-08 13:29:08.040 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-08 13:34:32.625
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 13:34:32.625
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7b8cb283,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38b54694,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 13:34:32.625
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7619fbe7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ead1b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-08 13:34:36.778
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 13:37:53.348
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 13:37:53.358
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-08 14:09:21.242
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:09:27.352
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:09:27.359
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:16.781
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:16.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:17.794
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:17.798
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:19.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:10:19.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:23:09.206
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:23:09.211
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:19.937
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:19.941
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:26.038
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:26.042
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:28.163
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:27:28.166
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:47:59.147
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:47:59.150
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-08 14:48:54.907 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-08 14:49:02.046
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 14:49:02.046
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c910acd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@612ac38b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 14:49:02.046
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9f2fe2e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4dd4965a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-08 14:49:08.214
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:49:19.501
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 14:49:19.513
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.core 4 4 2023-06-08 14:53:35.517
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Jse0001_varios_RepasosyPracticas2023 {

	public static void main(String[] args) {
	
		Jse0001_varios_RepasosyPracticas2023 appJse0001 = new Jse0001_varios_RepasosyPracticas2023();
		
		try {
			
			 appJse0001.conversionesTiposBasicas(); //(1)
			
			// appJse0001.polimorfismos(); //(2)
			
			// appJse0001.collections_1_basico(); //(3)
			
			// appJse0001.maps(); //(4)
			
			// appJse0001.trycathall(); //(5)
			
			//appJse0001.creandoApiClasesGenericsT(); //(6)
			
		    //appJse0001.collections_2_avanzado(); //(7)
		    
			// appJse0001.collections_3_avanzado(); //(8)
			
			// appJse0001.REGEXs(); //(9)
			
			// appJse0001.FilesJava7Avanzado(); //appJse0001.pruebatmp(); //.FilesJava7Avanzado(); //(10)
			
			// appJse0001.Hilos(); //(11)
			
			// Java 8:
			
			// appJse0001.exprsLambdas();  //(12)
			
			// Metodos por Defecto ( @Default )//(13) : es solo @Default arrib del met de una <<I>>. 
			
			// Interfaces funcionales ( @FunctionalInterface ) //(14)  Es solo anotar una IFunc(1 solo met no def a impl) x buena pracica safe code
			
			//appJse0001.referencias_a_Metodos(); // ( es el operador :: ) 
			// ( saber: x ahora los metodos referenciados (::) no aceptan parametros (xq java no impl 1 caracterist llamada currificacion xa poder)

			//appJse0001.Java8NewCollectionMethods(); // (16) Java 8 ForEach, RemoveIf, Sort
			
			//appJse0001.Java8_Streams(); // (17) STREAMS
			
			// appJse0001.Java8_Optional(); // (18) OPTIONAL<T>
			
			//appJse0001.Java8_Streams_Paralelos(); // (19) STREAMS ( PARALELOS )
			
			//appJse0001.Java8_MAP_Nueva_Funcionalidad(); // (20) API MAP NUEVA FUNCIONALIDAD  
			
			//appJse0001.Java8_LOCAL_DATE_TIME_NEW_API(); // (21) API NUEVA JAVA 8 PARA FECHAS Y HORAS
			
			//appJse0001.Java8_HIGHT_ORDER_FUNCTIONS(); // (22) HIGH ORDER FUNCTIONS
			
			//appJse0001.RX_2_Java(); // (23) RX JAVA PROGRAMACION ASYNCRONA // PUSH PARADIGMA REACTIVO FUNCIONAL
			
									// ( resu teoria y ejs de aca: https://blog.joda.org/2016/03/var-and-val-in-java.html )
			// appJse0001.Val_Var_Let_y_Auto_InferencedTypes(); 	//-> new: add de urgencia: esto va a aparecer x todos lados desde j8 o sup.. BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb|bbbbbbbbbbbbbbbbbbbbbbbb
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	/*	---------------------------------------------------------------------------------------------------
		(1)Conversiones basicas de Tipos de datos
		----------------------------------------------------------------------------------------------------*/
	
	public void conversionesTiposBasicas() {
		//1) int a String:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
			
			int iInt = 10; 
			String strInt = Integer.toString(iBIBIBBBBBBBBBBIBBBBBBBBBBBBBIBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBNBBBBBBBHBJBBBBBBBBBBBBBBV BBBBBBBBBBBBBBBNBBBBBBBBNBB BBBBBBBBBBBBBBBBB B B B B B B B B BB B B B B B B B B B BB B B B B B BBBBBBBBBBB-BBBBBBBBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB+B);
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-06-08 14:53:35.519
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-06-08 14:53:35.519
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-06-08 14:53:35.533
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Jse0001_varios_RepasosyPracticas2023 {

	public static void main(String[] args) {
	
		Jse0001_varios_RepasosyPracticas2023 appJse0001 = new Jse0001_varios_RepasosyPracticas2023();
		
		try {
			
			 appJse0001.conversionesTiposBasicas(); //(1)
			
			// appJse0001.polimorfismos(); //(2)
			
			// appJse0001.collections_1_basico(); //(3)
			
			// appJse0001.maps(); //(4)
			
			// appJse0001.trycathall(); //(5)
			
			//appJse0001.creandoApiClasesGenericsT(); //(6)
			
		    //appJse0001.collections_2_avanzado(); //(7)
		    
			// appJse0001.collections_3_avanzado(); //(8)
			
			// appJse0001.REGEXs(); //(9)
			
			// appJse0001.FilesJava7Avanzado(); //appJse0001.pruebatmp(); //.FilesJava7Avanzado(); //(10)
			
			// appJse0001.Hilos(); //(11)
			
			// Java 8:
			
			// appJse0001.exprsLambdas();  //(12)
			
			// Metodos por Defecto ( @Default )//(13) : es solo @Default arrib del met de una <<I>>. 
			
			// Interfaces funcionales ( @FunctionalInterface ) //(14)  Es solo anotar una IFunc(1 solo met no def a impl) x buena pracica safe code
			
			//appJse0001.referencias_a_Metodos(); // ( es el operador :: ) 
			// ( saber: x ahora los metodos referenciados (::) no aceptan parametros (xq java no impl 1 caracterist llamada currificacion xa poder)

			//appJse0001.Java8NewCollectionMethods(); // (16) Java 8 ForEach, RemoveIf, Sort
			
			//appJse0001.Java8_Streams(); // (17) STREAMS
			
			// appJse0001.Java8_Optional(); // (18) OPTIONAL<T>
			
			//appJse0001.Java8_Streams_Paralelos(); // (19) STREAMS ( PARALELOS )
			
			//appJse0001.Java8_MAP_Nueva_Funcionalidad(); // (20) API MAP NUEVA FUNCIONALIDAD  
			
			//appJse0001.Java8_LOCAL_DATE_TIME_NEW_API(); // (21) API NUEVA JAVA 8 PARA FECHAS Y HORAS
			
			//appJse0001.Java8_HIGHT_ORDER_FUNCTIONS(); // (22) HIGH ORDER FUNCTIONS
			
			//appJse0001.RX_2_Java(); // (23) RX JAVA PROGRAMACION ASYNCRONA // PUSH PARADIGMA REACTIVO FUNCIONAL
			
									// ( resu teoria y ejs de aca: https://blog.joda.org/2016/03/var-and-val-in-java.html )
			// appJse0001.Val_Var_Let_y_Auto_InferencedTypes(); 	//-> new: add de urgencia: esto va a aparecer x todos lados desde j8 o sup.. BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb|bbbbbbbbbbbbbbbbbbbbbbbb
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	/*	---------------------------------------------------------------------------------------------------
		(1)Conversiones basicas de Tipos de datos
		----------------------------------------------------------------------------------------------------*/
	
	public void conversionesTiposBasicas() {
		//1) int a String:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
			
			int iInt = 10; 
			String strInt = Integer.toString(iBIBIBBBBBBBBBBIBBBBBBBBBBBBBIBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBNBBBBBBBHBJBBBBBBBBBBBBBBV BBBBBBBBBBBBBBBNBBBBBBBBNBB BBBBBBBBBBBBBBBBB B B B B B B B B BB B B B B B B B B B BB B B B B B BBBBBBBBBBB-BBBBBBBBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB+B);
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-06-08 14:53:35.535
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-06-08 14:53:35.536
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3278)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3055)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-06-08 15:00:37.416 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-08 15:00:43.675
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 15:00:43.675
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4780341,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c910acd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-08 15:00:43.675
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@612ac38b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9f2fe2e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-08 15:00:49.009
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:16:54.346
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:16:54.362
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:32.860
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:32.868
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:42.232
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:21:42.237
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:38:39.219
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 17:38:39.223
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:01:07.661
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:01:07.667
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:26.781
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:26.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:40.962
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:40.965
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:44.717
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:18:44.723
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:19:18.937
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:19:18.939
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:29:41.692
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:29:41.696
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:30:19.507
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:30:19.511
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:37.236
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:37.239
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:59.059
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:35:59.062
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:36:11.158
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 18:36:11.161
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 19:19:08.544
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 19:19:08.549
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:46:51.825
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:46:51.835
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:47:01.120
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 20:47:01.123
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:07:40.826
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:07:40.828
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:18:27.425
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:18:27.428
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:24.950
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:24.954
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:30.481
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:19:30.484
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:20:02.412
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:20:02.416
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:23:45.192
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:23:45.196
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:24:20.668
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:24:20.671
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:37.358
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:37.361
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:55.310
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:34:55.314
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:35:10.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:35:10.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:37.701
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:37.708
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:47.311
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:37:47.314
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:46:29.653
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-08 21:46:29.656
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-09 12:45:05.905 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-09 12:45:12.638
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-09 12:45:12.638
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@578d472a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1191029d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-09 12:45:12.638
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54b2d002,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d1c63af,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-09 12:45:22.416
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:52:13.624
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:52:13.636
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:57:02.430
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:57:02.436
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:00.293
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:00.296
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:58.556
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:58:58.559
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:59:37.976
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 12:59:37.980
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:01.515
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:01.519
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:46.259
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:00:46.262
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.ui 2 0 2023-06-09 13:42:06.390
!MESSAGE The 'org.eclipse.jdt.ui.JavaAllCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.ClassCastException: class org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding cannot be cast to class org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding (org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding and org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @3741071d)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.computeExpectedTypes(CompletionEngine.java:4318)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2000)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2344)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:136)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:256)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:218)
	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:65)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:352)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:351)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:43:45.099
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:43:45.103
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:45:35.734
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:45:35.737
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:46:41.314
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:46:41.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:09.237
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:09.241
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:26.805
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:47:26.809
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:49:40.541
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:49:40.545
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:53:22.559
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 13:53:22.562
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:10:39.190
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:10:39.193
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:30.111
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:30.117
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:36.692
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:36.695
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:59.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:15:59.255
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:17:59.679
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:17:59.683
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:21:00.655
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:21:00.659
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:32:25.135
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:32:25.138
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:06.480
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:06.484
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:39.218
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:38:39.221
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:39:07.908
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:39:07.911
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:46:15.150
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:46:15.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:56:45.344
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 14:56:45.348
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:25.297
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:25.299
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:55.631
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:24:55.633
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:25:53.156
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:25:53.158
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:27:25.197
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:27:25.200
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:21.435
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:21.439
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:26.209
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:35:26.212
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:39:55.351
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:39:55.354
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:18.935
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:18.939
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:47.715
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:40:47.719
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:06.962
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:06.966
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:35.998
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:42:36.001
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:43:22.769
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:43:22.773
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:51:30.750
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:51:30.753
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:06.090
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:06.093
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:57.147
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:52:57.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:57:05.966
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:57:05.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:01.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:01.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:12.999
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 15:59:13.002
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:01:30.432
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:01:30.436
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:02:31.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:02:31.255
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:09.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:09.973
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:19.064
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:03:19.066
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:16:20.582
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:16:20.585
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:17:48.428
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:17:48.432
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:18:36.853
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:18:36.856
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:20:34.967
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:20:34.970
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:10.194
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:10.197
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:25.473
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:21:25.477
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:22:04.202
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:22:04.206
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:35.029
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:35.031
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:41.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:23:41.850
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:24:20.802
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:24:20.805
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:26:32.901
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:26:32.904
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:30:59.150
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:30:59.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:31:46.786
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:31:46.789
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:34:05.917
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:34:05.921
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:36:10.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:36:10.595
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:42:53.534
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:42:53.537
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:20.640
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:20.643
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:24.346
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:24.348
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:43.126
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:43:43.128
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:53.965
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:53.968
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:57.220
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 16:45:57.223
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:34:18.472
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:34:18.477
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:15.924
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:15.927
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:29.612
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:29.616
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:42.543
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:42.546
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:58.332
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:35:58.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:37:16.859
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:37:16.862
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:38:20.154
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:38:20.157
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:40:58.273
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:40:58.275
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:17.904
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:17.907
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:41.479
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:41:41.481
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:42:10.593
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:42:10.596
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:05.824
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:05.829
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:11.806
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:11.808
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:26.916
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 19:43:26.918
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:48:39.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:48:39.075
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:33.155
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:33.158
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:46.699
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:49:46.702
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:51:44.227
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:51:44.230
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-09 20:52:51.441
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:54:50.632
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:54:50.635
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:56:53.778
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:56:53.782
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:10.506
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:10.509
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:26.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 20:57:26.322
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:00:49.091
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:00:49.095
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:02:43.114
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:02:43.117
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:40.257
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:40.260
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:51.232
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:51.235
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:58.402
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:03:58.405
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:11.741
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:11.743
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:46.015
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:04:46.018
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:05:19.232
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:05:19.234
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:07:20.708
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:07:20.710
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:09:16.161
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:09:16.164
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:16:06.921
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:16:06.924
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-09 21:32:28.587
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:33:10.262
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:33:10.264
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:36:09.715
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:36:09.954
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:38:34.045
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:38:34.048
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:39:22.138
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:39:22.140
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:41.438
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:41.441
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:51.944
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:40:51.947
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:41:07.427
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 21:41:07.430
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:25.589
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:25.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:57.443
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:14:57.445
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:15:11.024
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:15:11.026
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:16:05.288
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:16:05.290
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:19:23.818
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:19:23.821
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:23:25.301
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:23:25.303
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:03.246
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:03.254
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:05.317
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:05.322
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:30.600
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:37:30.602
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:27.312
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:27.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:47.379
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:39:47.381
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:40:07.825
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:40:07.828
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:10.171
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:10.174
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:31.478
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:41:31.482
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:42:32.833
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:42:32.836
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-06-09 22:42:59.785
!MESSAGE Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
!STACK 0
java.net.URISyntaxException: Illegal character in path at index 17: file:/C:/!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS/SISTEMAS/IDEs & Editors/server - side/java/java-2022-06/eclipse instancia practicas/../../../../../../../Users/carlo/.p2/pool/plugins/org.eclipse.m2e.maven.runtime_1.18.3.20220227-1319/jars/
	at java.base/java.net.URI$Parser.fail(URI.java:2966)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3137)
	at java.base/java.net.URI$Parser.parseHierarchical(URI.java:3219)
	at java.base/java.net.URI$Parser.parse(URI.java:3167)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URL.toURI(URL.java:1063)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.addJarsFromBundle(MavenRuntimeClasspathProvider.java:81)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:66)
	at org.eclipse.m2e.editor.lemminx.MavenRuntimeClasspathProvider.get(MavenRuntimeClasspathProvider.java:1)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base/java.util.HashMap$EntrySpliterator.forEachRemaining(HashMap.java:1837)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLExtensionRegistry.getXMLLSClassPathExtensions(XMLExtensionRegistry.java:81)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.getExtensionJarPaths(XMLLanguageServer.java:148)
	at org.eclipse.wildwebdeveloper.xml.internal.XMLLanguageServer.<init>(XMLLanguageServer.java:83)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.lsp4e.LanguageServersRegistry$ExtensionLanguageServerDefinition.createConnectionProvider(LanguageServersRegistry.java:161)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$0(LanguageServerWrapper.java:232)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:295)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:06.070
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:06.076
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:28.068
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:43:28.071
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:44:08.414
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:44:08.424
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:49:26.087
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:49:26.107
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:09.913
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:09.915
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:19.839
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:54:19.842
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:09.382
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:09.385
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:54.568
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:56:54.570
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:58:24.953
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 22:58:24.957
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:07:54.704
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:07:54.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:52:13.036
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:52:13.039
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:58:48.461
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:58:48.463
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:59:23.900
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-09 23:59:23.903
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:00.282
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:00.284
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:05.152
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:00:05.154
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:03:06.742
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-10 00:03:06.745
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:20.590
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:20.603
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:24.621
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:42:24.625
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:46:04.256
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 12:46:04.258
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 13:29:01.224
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-11 13:29:01.226
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 14:58:20.494
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 14:58:20.498
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:28:30.694
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:28:30.700
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:42:12.143
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:42:12.145
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:59:40.746
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 19:59:40.751
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:49:02.788
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:49:02.791
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:57:08.876
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 21:57:08.881
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:36:33.322
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:36:33.331
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:40:40.032
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:40:40.035
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:50:09.741
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-12 23:50:09.747
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 00:12:22.977
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 00:12:23.007
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-13 14:42:00.068 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-13 14:42:06.548
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-13 14:42:06.548
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@268f0ff3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11978f52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-13 14:42:06.548
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e0855b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@484b5a21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-13 14:42:13.498
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 16:28:24.510
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-13 16:28:24.529
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-14 11:47:37.634 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-14 11:47:52.131
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-14 11:47:52.131
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@484b5a21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16e5344c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-14 11:47:52.131
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-14 11:47:59.957
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:56:14.542
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:56:14.577
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:57:33.028
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:57:33.035
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:58:35.853
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 11:58:35.857
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:14:35.906
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:14:35.912
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:20:37.718
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 12:20:37.722
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:11:58.905
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:11:58.912
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:13:22.658
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 13:13:22.662
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 16:52:48.311
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 16:52:48.317
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:14:12.233
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:14:12.243
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:23:00.168
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:23:00.173
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:47:06.760
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-14 17:47:06.765
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-16 13:32:12.987 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-16 13:32:32.359
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-16 13:32:32.359
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16e5344c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-16 13:32:32.359
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55746340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-16 13:32:42.889
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-22 13:45:30.198
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-22 13:45:30.227
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-23 10:35:10.686 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-23 10:35:20.242
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-23 10:35:20.242
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16e5344c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-23 10:35:20.242
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55746340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-23 10:35:27.630
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 10:55:25.937
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 10:55:25.956
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 19:38:53.377
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 19:38:53.402
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:53:58.274
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:53:58.285
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:55:21.899
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-23 20:55:21.903
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:09:28.279
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:09:28.287
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:22:43.916
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 14:22:43.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:24.153
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:24.166
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:27.832
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:48:27.848
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:51:07.288
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:51:07.291
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:57:25.991
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 15:57:26.002
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:04:44.098
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:04:44.112
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:07:09.491
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 16:07:09.495
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:39:27.237
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:39:27.246
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.947
!MESSAGE Failed to stream using org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport@10d14d47 - falling back to org.eclipse.epp.internal.mpc.core.util.TransportFactory$$Lambda$1679/0x0000000801c21d88@72f9a529: Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 1
org.eclipse.core.runtime.CoreException: Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:112)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: javax.net.ssl.SSLException: Connection reset
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:127)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:369)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:307)
	at java.base/sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1689)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1063)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	... 3 more
	Suppressed: java.net.SocketException: Connection reset by peer
		at java.base/sun.nio.ch.NioSocketImpl.implWrite(NioSocketImpl.java:420)
		at java.base/sun.nio.ch.NioSocketImpl.write(NioSocketImpl.java:440)
		at java.base/sun.nio.ch.NioSocketImpl$2.write(NioSocketImpl.java:826)
		at java.base/java.net.Socket$SocketOutputStream.write(Socket.java:1045)
		at java.base/sun.security.ssl.SSLSocketOutputRecord.encodeAlert(SSLSocketOutputRecord.java:82)
		at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:400)
		... 39 more
Caused by: java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	... 35 more
Contains: Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.950
!MESSAGE Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
javax.net.ssl.SSLException: Connection reset
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:127)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:369)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:307)
	at java.base/sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1689)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1063)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
	Suppressed: java.net.SocketException: Connection reset by peer
		at java.base/sun.nio.ch.NioSocketImpl.implWrite(NioSocketImpl.java:420)
		at java.base/sun.nio.ch.NioSocketImpl.write(NioSocketImpl.java:440)
		at java.base/sun.nio.ch.NioSocketImpl$2.write(NioSocketImpl.java:826)
		at java.base/java.net.Socket$SocketOutputStream.write(Socket.java:1045)
		at java.base/sun.security.ssl.SSLSocketOutputRecord.encodeAlert(SSLSocketOutputRecord.java:82)
		at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:400)
		... 39 more
Caused by: java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	... 35 more
!SUBENTRY 2 org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.951
!MESSAGE Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.epp.mpc.core 4 0 2023-06-24 17:49:00.951
!MESSAGE Connection failed

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:323)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:976)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:472)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1443)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1047)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:241)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:53)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:298)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:583)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:212)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:105)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:182)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:175)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:133)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement$1.proceed(ExecChainElement.java:57)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:75)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:87)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:79)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:45)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:97)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:308)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.epp.mpc.ui 2 0 2023-06-24 17:49:00.954
!MESSAGE Failed to download resource for entry 'Jeeeyul's Eclipse Themes 2.3' (339851) from https://marketplace.eclipse.org/sites/all/themes/solstice/public/images/marketplace/default.png
!STACK 0
java.io.IOException: Pipe closed
	at java.base/java.io.PipedInputStream.read(PipedInputStream.java:307)
	at java.base/java.io.PipedInputStream.read(PipedInputStream.java:377)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader$1.read(FileReader.java:334)
	at java.base/java.io.BufferedInputStream.fill(BufferedInputStream.java:244)
	at java.base/java.io.BufferedInputStream.read1(BufferedInputStream.java:284)
	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:343)
	at java.base/java.io.BufferedInputStream.fill(BufferedInputStream.java:244)
	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:263)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$ResourceFuture.lambda$0(ResourceProvider.java:95)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$ResourceFuture.retrieve(ResourceProvider.java:149)
	at org.eclipse.epp.internal.mpc.ui.catalog.ResourceProvider$1.run(ResourceProvider.java:309)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-06-24 17:50:50.052
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:459)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	... 34 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-06-24 17:50:50.053
!MESSAGE Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
!STACK 1
org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
!SUBENTRY 2 unknown 8 1 2023-06-24 17:50:50.053
!MESSAGE 

!ENTRY org.eclipse.epp.mpc.ui 1 2 2023-06-24 17:50:50.057
!MESSAGE Skipping update check for repository 'https://download.eclipse.org/buildship/updates/e410/releases/3.x' - failed to read repository. Affected entries: 
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x.
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:190)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:459)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	... 19 more
Caused by: org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	... 34 more
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1002 2023-06-24 17:50:50.057
!MESSAGE Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x.
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:459)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	... 34 more
!SUBENTRY 2 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-06-24 17:50:50.057
!MESSAGE Unable to read repository at https://download.eclipse.org/buildship/updates/e410/releases/3.x/3.1.0.v20190501-0830/content.jar.
!STACK 1
org.eclipse.core.runtime.CoreException: 
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryStatusHelper.wrap(RepositoryStatusHelper.java:177)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.checkException(FileReader.java:543)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:465)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.readInto(FileReader.java:386)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.download(RepositoryTransport.java:107)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.download(CachingTransport.java:193)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.updateCache(CacheManager.java:430)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:265)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor73.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
!SUBENTRY 3 unknown 8 1 2023-06-24 17:50:50.057
!MESSAGE 
!SUBENTRY 1 org.eclipse.epp.mpc.ui 1 0 2023-06-24 17:50:50.057
!MESSAGE Buildship Gradle Integration 3.0

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:54:39.943
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 17:54:39.945
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:03:53.843
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:03:53.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:20:29.039
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 18:20:29.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:07:20.842
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:07:20.866
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:19:47.409
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:19:47.415
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:23:34.318
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:23:34.321
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-06-24 19:23:48.427 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-06-24 19:23:55.280
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-24 19:23:55.280
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f1ad846,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d5ae6aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-06-24 19:23:55.280
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2bc2e022,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2210e466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-06-24 19:24:02.262
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:38:11.334
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:38:11.347
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:43:38.983
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:43:38.990
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:57:59.699
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:57:59.703
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:58:24.744
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 19:58:24.748
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:04:21.638
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:04:21.641
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:06:45.046
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:06:45.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:08:42.720
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:08:42.724
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:21.907
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:21.913
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:37.750
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:13:37.753
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:15:57.542
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:15:57.545
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:18:11.329
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-06-24 20:18:11.332
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-06 14:32:07.450 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-06 14:32:14.032
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-06 14:32:14.032
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba5c4dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47fca3cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-06 14:32:14.032
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55746340,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a0c7af6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-06 14:32:20.460
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:29:59.929
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:29:59.944
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:33:33.480
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:33:33.489
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:42:49.551
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:42:49.556
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:44:32.657
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:44:32.660
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:54:26.414
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 15:54:26.418
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:26.117
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:26.121
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:41.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:00:41.709
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:02:15.885
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:02:15.890
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:03:05.488
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:03:05.491
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:10:35.112
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:10:35.115
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:10.503
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:10.506
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:32.849
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:11:32.852
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:12:43.967
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:12:43.970
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:45:07.434
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:45:07.444
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:57:30.876
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:57:30.886
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:58:25.675
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 16:58:25.682
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:09:45.563
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:09:45.567
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:11:54.664
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:11:54.667
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:13:28.167
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:13:28.170
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:14:54.844
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:14:54.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:19:12.498
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:19:12.501
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:31:12.511
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:31:12.523
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:44:17.009
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:44:17.022
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:49:49.259
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 17:49:49.262
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:27:09.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:27:09.058
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:36:08.688
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:36:08.693
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:06.094
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:06.096
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:57.363
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:39:57.367
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:54:51.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:54:51.710
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:56:52.514
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:56:52.518
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:32.088
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:32.091
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:57.643
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:58:57.646
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:59:16.799
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 18:59:16.802
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:02:15.224
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:02:15.226
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:04:05.949
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:04:05.952
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:07:01.290
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:07:01.293
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:02.657
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:02.661
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:32.385
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:13:32.388
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:26.834
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:26.839
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:39.332
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:19:39.335
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:28:15.066
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:28:15.069
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:30:19.847
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:30:19.849
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:59:17.776
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 19:59:17.780
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 20:00:01.987
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 20:00:01.990
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:38.941
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:38.950
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:54.969
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:25:54.972
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:26:30.000
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:26:30.003
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:38.012
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:38.017
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:48.156
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:28:48.161
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:29:12.721
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:29:12.724
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:03.665
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:03.668
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:21.338
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:21.339
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:41.300
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:30:41.303
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:31:11.383
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:31:11.385
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:34:09.097
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:34:09.100
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:35:49.003
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:35:49.005
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:36:15.139
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:36:15.144
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:16.281
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:16.283
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:38.565
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:40:38.571
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:21.676
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:21.687
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:41.178
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:42:41.182
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:47:37.324
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:47:37.329
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:50:20.948
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 22:50:20.951
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:14:51.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:14:51.261
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:07.266
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:07.271
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:13.103
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:13.108
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:33.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:16:33.257
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:08.136
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:08.139
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:36.111
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:36.114
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:43.079
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:43.082
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:52.574
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:19:52.579
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:08.901
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:08.905
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:36.047
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:36.050
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:52.597
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:20:52.599
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:21:02.981
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:21:02.984
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:18.951
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:18.954
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:22.268
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:22.271
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:25.127
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-06 23:32:25.129
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 01:22:51.214
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 01:22:51.218
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-07 15:16:06.676 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-07-07 15:17:02.903
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-07-07 15:17:05.780
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-07 15:17:05.781
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0b0bd9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6150afc6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-07 15:17:05.781
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49f50c8f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46e6458d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-07 15:17:11.840
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:17:13.608
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:17:13.620
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:29:53.252
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:29:53.264
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:40:16.991
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:40:16.996
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:42:00.947
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:42:00.951
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:44:33.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 15:44:33.787
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:47:14.694
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:47:14.699
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:11.345
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:11.349
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:20.340
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:49:20.345
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:56:02.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:56:02.069
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:02.667
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:02.671
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:24.832
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 16:58:24.835
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:10:40.356
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:10:40.360
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:33.566
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:33.569
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:43.215
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:30:43.218
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:41.744
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:41.748
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:57.002
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 17:37:57.007
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:38:00.429
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:38:00.432
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:45:16.642
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:45:16.646
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:48:37.074
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 18:48:37.078
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 20:54:43.437
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-07 20:54:43.451
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:05:11.706
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:05:11.718
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:17:58.851
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:17:58.859
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:18:33.558
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:18:33.561
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:19:55.598
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:19:55.601
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:20:56.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:20:56.929
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:21:57.417
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:21:57.420
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:13.914
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:13.917
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:54.943
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:24:54.945
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:25:09.717
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:25:09.721
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:30:59.216
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:30:59.219
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:11.826
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:11.829
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:41.700
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:41.703
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:56.468
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:33:56.470
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:36:15.603
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:36:15.605
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:46:06.306
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 15:46:06.317
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:08:03.076
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:08:03.084
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:16:31.472
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:16:31.475
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:21:03.245
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:21:03.247
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:28:56.011
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 16:28:56.015
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:38:40.466
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:38:40.475
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:39:46.330
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:39:46.333
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:40:20.595
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:40:20.598
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:50:49.124
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:50:49.130
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:53:16.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:53:16.069
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:56:54.723
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:56:54.725
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:58:01.173
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:58:01.176
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:59:09.065
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 18:59:09.067
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:36.906
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:36.910
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:46.784
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:01:46.787
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:03:57.814
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:03:57.817
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:04:02.231
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:04:02.234
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:05:26.078
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:05:26.080
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:07:13.643
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:07:13.645
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:08:14.717
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:08:14.719
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:25.263
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:25.266
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:31.777
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:09:31.779
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:11.625
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:11.628
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:30.142
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:30.145
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:50.368
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:11:50.371
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:18.764
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:18.766
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:22.344
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:22.347
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:30.820
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:14:30.823
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:15:05.452
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:15:05.454
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:16:26.112
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:16:26.115
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:00.282
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:00.285
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:45.685
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:18:45.688
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:19:30.924
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:19:30.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:20:19.800
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:20:19.802
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:22:00.514
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-08 19:22:00.517
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-13 11:30:25.826 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-13 11:30:35.242
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-13 11:30:35.242
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@257b3561,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78861d9e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-13 11:30:35.242
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a878778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-13 11:30:43.922
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:31:52.739
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:31:52.752
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:32:59.919
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:32:59.926
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:33:10.554
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:33:10.558
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:48:48.429
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 11:48:48.433
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:47:13.204
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:47:13.211
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:56:26.606
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 12:56:26.609
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:15:51.661
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:15:51.666
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:49.185
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:23:49.189
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:23:49.189
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:49.405
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:23:49.406
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:23:49.407
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:49.431
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:23:49.432
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:23:49.433
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:23:50.359
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:23:50.360
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:23:50.361
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:07.627
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:24:07.628
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:24:07.629
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:07.648
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:07.650
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:07.650
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:08.649
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-13 13:24:08.650
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-13 13:24:08.650
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:11.664
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:11.665
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:11.666
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:12.251
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:12.252
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:12.252
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-13 13:24:12.624
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList;	 //		( CLAVE: tener 2 modalidades: 
							 //		  -----				-> 		Programar x tiempos x obj basico cumplir. y otra es yo tranki xa aprender pero sino sin pensar ni aprender.
import java.util.Arrays;	 //												solo resolver como sea xa alcanzar el objetivo al minimo posible )  !!!!!!!!!!!!!!!!  

import java.util.Collection;		// -> TIP CLAVE XA TRABAJAR: LA MEGA CLAVE ES PENSAR EN ALGORITMO - VERLO - USAR LA MENTE A FULL SIN VAGO - RAZON CLARO Y LOGICO
									//		  -----			( NUNCA empezar algo si no lo tengo mas o menos claro y resuelto del vamos sino barullo sin salida ) !! 
									//			" CUANDO TRABAJO NO ANALIZO DE MAS OSEA NO INVESTIGO EXTRA . RESUELVO LOGRO EL OBJETIVO ( luego se v.. ) !!!!!!!!!
import java.util.Collections;
import java.util.Iterator;		// Me anoto los TODO xa realizar ( si son TODO posta es xq deberia hacerlos y no obviarlos , sino uso TO-DO xa lo los opcionales )
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;		// CLAVE: SIEMPRE MODULARIZAR TO-DO asi code qda casi coloquial. y comentar al lado los if en coloquial me ayuda!    
									// y estos methods "helpers" TESTEARLOS SIEMPRE X SEPARADO 1ERO! ( TDD ) no asumir q andan xq en ellos se basa mi alg ppal!!!!

//	OJJOOO LEARNING: CLAVE : ->  !!! SI VOY A METER UN CAMBIO MUY GRANDE ( MUCHO CODE O MUY DIFICIL ) TENER BACKUP DE LA VERSION ANTERIOR !!! ( TODO USAR GIT !!! )
//	y TIP: Borrar de a bloques, hasta dejar el code sin errors (osea volver a lo de antes) e ir luego poniendo de a poco de ultima las modifs xa > ctrl de donde hay err!! 
//  ----------------------	
	//CLAVE: (L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema! "DIVIDE Y TRIUNFARAS!" -a+ , dividir!
//	(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
//	(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
//		luego lo cerr codeando pero era casi eso mismo! 
//		y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez ajustar las boludeces ( o xa enternder algo)!!!!!!!!!!!
//							-----------------------------CLAVE--------------------------------- 	

// Learnings grales ( extra code) :
	// tecnica siempre probar mas basico e ir de < a >!!! **v (este es un ejemplazo)		 ( debuggear, googlear, caso simple xa probar, preg a la IA etc sirve/suma )
	// Pensar en voz alta ayuda. meter comentarios en mi codigo q es xa pensar tmb ayuda a razonarlo bien.
	// CLAVE: PRIMERO DISEAR EN HOJA! TODO. Cualquier algoritmo/ito xa pensar. precond siempre anotar coloquial analisis pseudo cod o idea antes de empezar algo! siempre!
	// -> NO EMPEZAR A CODEAR UN ALGORITMO SI ES XA PENSAR Y NO LO TENGO CLARO DE ANTEMANO. ( y si se complica o x lo gral siempre si hay tiempo , evaluar <>s alternativas)
	//	( siempre puedo impl el caso "ideal" pero luegodebo prever todos los <>s inputs, [ ent <>s tratamientos ] [ent <>s salidas ej un msje q no se puede, etc] )
	// BUENAS PRACTICAS. PENSAR EN VOZ ALTA. NO AUTO BLOQUEO. SIN HOJA. Q LABURE EL BOCHO. ESFUERZO PERO TRANQUI A SU VEZ. COMENTAR TMB AYUDA .
	//(L)earning: SIEMPRE Es mejor usar vars x/c/cosa asi qda mas claro el code q hacer calculos raros en medio del code sin aclarar q reflejan ..
	// USAR T O D O xa lista de pends asi que evitarlo como comentarios en mi code. y ojo sigo siendo muy perfeccionista y vueltero. cuando +o- me acomode ahi si por 
	//			cronometro y objetivc y TDD etc. ( me vuelve muy vueltero en generalizar todo , ojo, si poco tiempo ent no se.. depende.. saber manejar eso )
	// En esta clase de ejemplos scrollear que hay muchos learnings de configuracion de eclipse tmb xa customizar mis cosas xa > comodidad , prolijidad , performace o 
	// recordarme tdd objetivos input outpu osea como pensar ( xq SIEMPRE EN T ODO LO QUE HAGA DEBO ARRANCARLO CON LA TECNICA BUENAS PRACTICAS CORRECTAS (ya sea prog, 
	// viola, tango, vida, etc)
	// si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!!!!!!!!!!!!! 
	// (ver q uso CLAVE como ancla xa <>s Obs mias importantes, siempre).

// Nueva plantilla final q agrupa a todas las otras: pongo abc + (ctrl + spc) y PLANTILLA COMPLETA XA EMPEZAR UN NUEVO METODO!! Vers final ( abc + autocomplete y listo!) 
// PLANTILLA ANALISIS COLOQUIAL SIEMPRE Y ANTES QUE CODEAR CUALQUIER COSA.  ( Y Objetivo claro. y enfoque TDD (lo min q cumpla) )
// ----------------------------									( *** usarlo tmb xa Interfases ya q new_java files context sirve xa todo new file rel c/java )
	// ( y tmb modifiqu el new_class a mi gusto pero este se hace desde windows -> preferences -> java -> code style -> code templates -> code -> new_files (edit )***) 
																				// 	(se hace ahi xq es xa q el IDE lo ejec auto desde xej: men: file -> new -> class)
										// mi custom template ( orig modif ):
										// ------------------

										// ${package_declaration}
										
										// /**
										//  * 	Description of ${file_name}
										//	* 
										//	* 
										//	*	@author 	 ${user}
										//	* 
										//	*	@version	 ${date} ${time}
										//	* 
										//	*	@see
										//	*/
											
										//	${type_declaration}

										// --------------------------------------

		//ej:  Analisis Coloquial (idea gral de la impl ):	la idea es .. bla bla .. 
		//--
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los..ETC 

		// ____________________________________
		//	(*planti) plantilla limpia 					( xa copiar y pegar: ) Nooo mejor ya hice un template: planti + ctrl + spc (ide autocomplete) (*expli)
		// 	__________----------------__________								y tmb hice uno xa la desc cabecera del metodo con fecha autor y description 
		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   		pero no lo hice custom sino que modifiqu el que viene x default : pasos :
		// 																		Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama 
		//			salida:  													private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)  
		//			entrada: 													y saber q esto est en : 
		//			proceso:													windows - preferences - java - editor - content assist - templates
		//		  			  													(Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default))
		// 	____________________________

// https://www.w3resource.com/java-exercises

// New (code learnings) from estos ejercicios: (	Obs: los dejo en el code, y como shortcut busca (**L) en el documento xa ver cada learning en su lugar	)

//		Indice de learnings ( hiper Resu ) :
//		1. Vecs o Arrs (no coll) si o si se init c/un tam fijo (max)! y no se pueden ni redimensionar!, ni sumar mas elems salvo copy a 1 arr new > o con collections.
//		2. Si voy a necesitar ref a pos concretas en los arrs de in o en el/los de out ent SIEMPRE recorrerlos c/un for c/indices xqeso yame lleva un cont xa (f,c) 
//		3. 


public class Jse0001_varios_Full_Practicas2023 { //Obs: las practicas implementarlas mejor x cada ejercicio un metodo del ejercicio, asi template o pruebas junit + adel.!

	public static void main(String[] args) {
		
		Jse0001_varios_Full_Practicas2023 ejsInstance = new Jse0001_varios_Full_Practicas2023();
		
		// Practicas from : https://w3resource.com/java-exercises/

		// A) java-exercises/basic/index1.php :
	
			//A.154)	
				//ejsInstance.vecOfVecsToArray();  // 		( Obs: A.154 es de esta url del punto A el ejercicio nro 154 )  
		
			//A.155)	
				//ejsInstance.rowsByColsSwitchArray();
			
			//A.159
				// ejsInstance.findKGreatestNumbersInArray();	// TODO : Estos metodos deben recibir el array, el k, etc como parametros!! (en todos los ejs q hice falta!!)

			//A.162
				// ejsInstance.findNumbersGreaterThanAverageInIntArray();
			//A.167
				// ejsInstance.move0sToRightInArr();
			//A.169
				// ejsInstance.reverseString();
			//A.175
				   ejsInstance.synglyList();
	}

	//A.154) 
		
	public void  vecOfVecsToArray() {
		

		/** (TDD)
		*
		*	Analisis / Objetivo: este ya lo comente x dentro.. me da paja pero los proximos los comento de una ac.. 
		*	Entrada:
		*	Salida:
		*	Proceso / PseudoCode: 
		*/
		
		//BASIC 2: ->	https://www.w3resource.com/java-exercises/basic/index1.php

		//	154. Write a Java program to print the contents of a two-dimensional Boolean array where t represents true and f represents false.
		//
		//	ex:
		//		array = {	{true, false, true}, {false, true, false}	};		//1 dim 
		//		Expected Output : 		
		// 							t f t 										//2 dim (2x2)
		// 							f t f
		
		//boolean[] bArr = {	new []boolean, new []boolean	};	// tecnica siempre probar mas basico e ir de < a >!!! **viene (este es un ejemplazo)
		//pruebo lo simple:
		//boolean [] bArr = { true, false};	<- Funciona lo + basico! ent:
		//joya ahora si:
		boolean[][] bArr = {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!

		//		(**L)earning: En Java, los arreglos (arrays) tienen un tamao fijo que se establece al momento de su creacin. Si defines un arreglo de tipo char de tamao 2, 
		//		no puedes agregar automticamente un nuevo elemento ms all de ese tamao sin redimensionar el arreglo.
		//
		//		Para lograrlo,tendras q crear un nuevo arreglo c/un > tamao y copiar los elems existentes al nuevo arr.Afortunadamente, Java proporciona la clase ArrayList 
		//		que es una implementacin de una lista redimensionable, lo que facilita agregar nuevos elementos sin preocuparte por redimensionar manualmente el arreglo.

 		char[][] chrVec = new char[2][3];
		char chrNewElem;
		
		// (**L)earning: Si voy a necesitar trabajar con indices Entonces Recorrerlos con indices!
		
		//		for (boolean[] bs : bArr) {
		//			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
		//					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
		//				} 
		//			}
		//		}

		// (**L)earning: PRIMERO MI ANALISIS EN COLOQUIAL PARA EL ALGORITMITO:       ( SIEMPRE ANALISIS COLOQUIAL 1ERO!!! ) 
		// Analisis Coloquial (idea gral de la impl ):	 
		//
		//		-> 	Objetivo: salida:  1 array de misma dim de los vecs en cuanto a cols y cant de vecs como filas (ves, si pienso asi y bn se v h' una impl generica),
		//									cuyos elems son la transf delos valores de los vecs de entrada pero acomodados por filas en esta matriz qlos agrupa como mat.
		//					  entrada: 2 vecs cuyos elems tmb son vecs de elems
		//					  proceso: recorro cada elem(qson vectores tmb), del vec de entrada. Por elem(vec) del gral, en ese bucle recorro sus cols o elems y los 
										//agrego en el iContActual (indice de fila) tmp q llevo xa "agregar" filas a mi mat , en ese icontfila y en el icol del cont del 
		//											bucle q esta recorriendo los elems del vec actual (xq c/elem puede verse como una col ,es lo mismo el concepto en mat) 
		//											asi q en el bucle de por cada elem (char) de cada vec interno (xa cada vec interno) tengo c/elem de estos (col xa mat)
		//											y el indice icontfilasmattmp q lo llevo en el bucle de afuera q recorre el vec ppal contenedor ,x lo q tengo el elem 
		//											para la mat final y llevo contada y tengo la pos xa la mat final xa agregarlo, en este caso, me pide una transformacion
		//											de cada elem ( son boolean y los quiere a 1 char q sea 't' o 'f' segun el boolean sea true o false. creo mi func de transf
		//											y agrego finalmente el elem transformato a la mat salida en la pos fila,col q corresponde (xq ya tengo todo) !! FIN-
		// (**Learning:	Como voy a necesitar indices x necesitar referirme a posiciones concretas(en el de salida) ent SIEMPRE conviene usar indices xa recorrer los de 
		//				entrada xq necesito sus indices; sino tomaria cada elem de entradas con 2 foreach pero no sabria donde (en q pos) poner en la salida xq no llevo 
		//				conts de filas y cols de nada ) 
		
		/*esta forma de recorrer no me sirve si voy a necesitar trabajar con indices (si necesitar referenciar indices concretos ent necesitar llevar 
			contadores x cada indice mejor un for con index asi ya auto los iActuales  
			for (boolean bsElem: bs) {	// Recorre cada subvector internamente, osea no recorre los elems del vec contenedor ppal  
					chrNewElem = boolToCharIndicator(bs);		//  (sino los elems x cada vec interno de 3 elems c/u en este caso).
						
				} 
			}
		*/
		// recuerdo vars:	
		
		//  	boolean[][] bArr 	= {	{true, false,true },{false,true, false}	}; // array de arrays! = matriz!
		// 		char[][] 	chrVec 	= new char[2][3];
		// 		char chrNewElem;	
		// ent: 
		// Algoritmito :
					// ..probarlo a ojo yl con JUNIT ( viste q si razono al programar no me embarullo!!!) siempre foco pilas esfuerzo nunca bocho vago es la CLAVE !!!
		boolean[] subArrActual; 
		boolean subArrActualBoolElem;
		for (int i = 0; i < bArr.length; i++) {
			subArrActual = bArr[i];
			for (int j = 0; j < subArrActual.length; j++) {
				subArrActualBoolElem = subArrActual[j];
				chrNewElem = boolToChar(subArrActualBoolElem);
				chrVec[i][j]=chrNewElem;
			}
		}
			
		// TODO deberia testearlo con Junit los proximos, pero este lo recorro con un foreach xa mostrar los rtados x consola y los chequeo a mano ( a ojo ) .. 
		//	( es mas, voy a hacer un testeo de este ya que tengo la mat de inputs (como vecs of vecs pero no deja de ser una mat) , con elems 
		//	valores ktes y la salida buscada asi que puedo crear aun mas facil el test case o caso de prueba , con junit (junit 5).    
		
		}

	//}
	
	
	public static char boolToChar(boolean b) { // la dejo static como metodo util en gral. incluso deberia sacarlo a una clase de utils de strings xero ya fue
		return b==true?'t':'f';
	}

		//	Analisis Coloquial (idea gral de la impl ) -> Objetivo:  	   
		//
		//		  			  salida:  
		//					  entrada: 
		//					  proceso:  

	
	/** 
	* Jul 6, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	Write a Java program to print an array after changing the rows and columns of a two-dimensional array.
					ex: Original Array: 10 20 30
										40 50 60
						After changing the rows and columns of the said array:
										10 40
										20 50
										30 60 */
	//A.155) 
	
		public void  rowsByColsSwitchArray() { 

			/** (TDD)
			*
			*	Analisis / Objetivo:
			*	Entrada:
			*	Salida:
			*	Proceso / PseudoCode: Basicamente s la dim del de salida xq es la del de entrada invertidas filas lenght y cols lenght. asi q defino la estructura de
			*							salida y luego el algoritmo es sencillo, recorro el arr de input , tomo su f y su c y lo almaceno como c,f en el de salida. fin. 
			*/
			
			int[][] inIMat = {{10,20,30},{40,50,60}};					// Obs! outMat es CxF de in!
			int[][] outIMat = new int[inIMat[0].length][inIMat.length]; // (L) Obs: The length of a 2D array is equal to the number of rows it has.   
																		// 			The number of columns may vary row to row, which is why the number of rows is used as 
																		//	     	the length of the 2D array. ( luego yo uso [0] .lenght xq asumo all rows same lenght)
			printMat(inIMat);
			for (int i = 0; i < inIMat.length; i++) { //Filas (obtengo c/arr (vec) (elem del arr ppal) )
				for (int j = 0; j < inIMat[0].length; j++) { //Cols (c/elem final, puntual xa ambas coordendas )
					outIMat[j][i] = inIMat[i][j];
				}
				
			}
			printMat(outIMat);
		}
	
		
		//TODO Ojo podria hacer un imprimir matriz de cualquier tipo de numeros ( usando generics! ) o incluso uno mas general para objetos q tengan toString impl etc..
		public static void printMat(int[][] iMat ) {
			System.out.println();
			 for (int i = 0; i < iMat.length; i++) {
				for (int j = 0; j < iMat[i].length; j++) {
					System.out.print(iMat[i][j] + " ");
					if (j==iMat[i].length-1) System.out.print("\n");
				}
			}
		}
		
		//A.159) 
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	Write a Java program to find the k largest elements in a given array. Elements in the array can be in any order.
		* 				ex: if k = 3 and in arr = [1, 4, 17, 7, 25, 3, 100]  then Expected Output: 100 25 17 
		*/
		
		public void  findKGreatestNumbersInArray() {	// La idea es ser + productivo y no tantas opciones aunque si requiere performance o hay tiempo ent ver <>s alternativas.
			/** (TDD)
			*
			*	Analisis / Objetivo: 	obj: Encontrar los k mayores enteros en un array de enteros desordenados
			*	Entrada: 				in:  un arr de input 
			*	Salida:  				out: los k int elems mayores del arr de input
			*	Proceso / PseudoCode: 	alg: op1: puedo ordenar el arr ( con ord burbuja o + simple usando el api collection xa este caso!) y ahi tomar los 1eros 3!. fin.
			*								 op2: puedo recorrer el arr y tomar el mayor e imprimirlo. pero luego eliminarlo o ponerle sobreescribirle con el numero mas 
			*											bajo posible xa q no salga mas elegido ( esto puedo laburarlo en una copia del array xa no modif el orig ) y luego
			*											recorrerlo de nuevo y mismo proced de sacar el mayor y quitarlo o sobreescribirlo xa q no salga yl k veces
			*								 op1 vs op2: 
			*											op1: ventajas:	Es mas claro. recorre 1 vez el array para ordenarlo y nada mas. 
			*															( no recorre k veces ni usa copias en mem ni sistemas raros de overrides etc )
			*								 Decision: OP1
			*							
			*							 Obs: Si me pidieran los k impares mayores. idem pero el alg xa tomar los k impares mayores seria un alg no solo de dame los 
			*							k elems primeros q son los mayores sino otro recorrer el arr ordenado hasta tomar k elems en ese orden pero q cumplan ser impares.    							
			*/								 

			//a) in:	
					
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100}; 
			
			//b) alg:	

				/* ***** (L)earning:
				 *  
				 * 	 Problema:
				 *	  		Arrays.asList(array)
				 *	  
				 *			this can cause the problems in cases when we doesnt need a imutable collection  
				 *			especially if it does not work for arrays of primitive type values: int[] array = new int[] {1,2,3,4}; Arrays.asList(array) :: List<int[]> 
				 *	
				 *	 Rta interesante pero no funca(la dejo porque xas objetos sirve pero xa tipos primitivos ver la Rta posta q es add 1x1 a una nueva lista de Integers)
				 *
				 *		If you don't want to alter the list:										// Saber: No funcan ( la rta estaba mal para primitivos no se puede )
				 *																					//			( pero la dejo xq xa Objs sirven (creo) .. )
				 *		List<Integer> list = Arrays.asList(array)
				 *		But if you want to modify it then you can use this:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(Arrays.asList(ints));
				 *		Or just use java8 like the following:
				 *		
				 *		List<Integer> list = Arrays.stream(ints).collect(Collectors.toList());
				 *		Java9 has introduced this method:
				 *		
				 *		List<Integer> list = List.of(ints);
				 *		However, this will return an immutable list that you can't add to.
				 *		
				 *		You need to do the following to make it mutable:
				 *		
				 *		List<Integer> list = new ArrayList<Integer>(List.of(ints));
				 *
				 ***********************************************************************************************************
				 *	  Rta Posta:
				 ***********************************************************************************************************	
				 *		There is no shortcut for converting from int[] to List<Integer> as Arrays.asList does not deal with boxing and will just create a List<int[]> 
				 *			which is not what you want. You have to make a utility method.
				 *
				 *		int[] ints = {1, 2, 3};
				 *		
				 *		List<Integer> intList = new ArrayList<Integer>(ints.length);
				 *		
				 *		for (int i : ints)
				 *		{
				 *		    intList.add(i);
				 *		} 
				 ***********************************************************************************************************/
				// imprimo el input , data del ej , x consola:
				printVec(iArrIn);
				
				//alg:
				
				//def 1 lista from arr xa trabajar sobre ella con collections.sort que trabaja con listas
				List<Integer> iList = new ArrayList(iArrIn.length);
				
				//cargo a mano la lista con la data del array original ( a mano xq el arr es de tipo primitivos ent el asList no funciona )  
				for (int i = 0; i < iArrIn.length; i++) {
					iList.add(iArrIn[i]);
				}
			
				// Ordeno la lista
				
				//Collections.sort(iList); 
				
				// No funcaba														// SUPER LEARNING CLAVE RECORDAR SIEMPRE ESTO PRESENTE / SABER:
				
				//Collections.sort(iList, (x,y)-> (y >= x)?y:x ); // CLAVE:(L) La clave es q espera un comparator osea una impl de este osea la impl de su metodo compareTO  
																		// 	y el compareTo devuelve un positivo si es mayor o un negativo si es menor!! aca no respetaba
																		//	esa logica! lo que hacia yo no es dev >0 ==0  <0 sino devolver el menor y el comparator 
																		//	(metodo compareTo) no est pensado de esa forma aunque los tipos que yo devolvia eran compatibles 
																		//	no respetaba la logica de funcionamiento de como debia implementarse la logica de esa interfaz!!!
																		// 	X LO TANTO SIEMPRE IMPL LA I Q ESPERA (EL MET DE LA I FUNCIONAL Q ESPERA ) CON LA FIRMA Y CON 
																		//	LA LOGICA! DEL VALOR DE RTADO QUE DEBO RETORNAR EN CADA CASO!! LA LOGICA LA PUEDO CAMBIAR XA 
																		//	ESO ESTAN PERO NO LA LOGICA DEL TIPO DE RTA Q ESPERA XA CADA CASO ( VER SIEMPRE LA DOC DE LAS 
																		//	INTERFACES Y RETURN VALUES XA CADA CASO XA RESPETAR SU LOGICA DE RTA Y ENT DE ACOMPLAMIENTO Y 
																		//	FUNCIONAMIENTO YA CON ESA MANERA QUE IMPONE!!)
				//funca
				Collections.sort(iList, (x,y)-> (y >= x)?1:-1 ); // (L)earning recordar q sort modifica la lista que le paso ( trabaja sobre esta y le reordena la data , 
										 //			puede xq son objs ent es x ref y sus elems tmb xq son objs integers tmb ) 
										 //			Osea: En Java, los parmetros de mtodos se pasan por valor. Cuando pasas una lista como parmetro, 
										//					se pasa la referencia a la lista, no una copia de la lista en s. Esto significa que el mtodo 
										//					tiene acceso a la misma lista y puede modificar su contenido.
				
				//funca:
				//Collections.sort(iList, (x,y) -> y.compareTo(x)); //(L)earning SUPER LEARNING! SABER: la expr** no funcionaba por lo siguiente!!:
																	//	El mtodo Collections.sort() espera un comparador que implemente la interfaz Comparator, 
																	//	que define el mtodo compare() que compara dos elementos y devuelve un valor que indica su 
																	//	orden relativo. En tu expresin lambda, ests intentando usar una comparacin VALIDA PERO 
																	//	<> A LO Q LA I ESPERA COMO RTA XA DETERMINAR SU RTADO! 
																	//	(x > y) ? x : y para determinar el mayor de los dos elementos, pero eso no es compatible 
																	//	con la interfaz Comparator.En esta expresin lambda, utilizamos el mtodo compareTo() de la 
																	//	clase Integer para comparar los elementos en orden descendente. La comparacin y.compareTo(x) 
																	//	devuelve un valor negativo si y es menor que x, lo cual indica que y debera ir antes que x en la lista.

																	// Recuerda que para que esta sentencia funcione correctamente, iList debe ser una lista de  
																	//		objetos Integer (por ejemplo, List<Integer>)   
				
				System.out.println("imprimo la lista ordenada: ");
				for (Integer elem : iList) System.out.print(elem + " ");
			//c) out: Expected Output: 100 25 17  						( TODO hacer un test de unidad tmb para este ejercicio! ) 
															// ( TODO: siempre deberia dar robustez ante todo caso de inputs ej k > arr.lenght , k=-1 etc ) !!
				final int K=3;
				System.out.println(" Los " + K + " enteros mayores de la lista son: ");
				for (int i = 0; i < K; i++) System.out.print(iList.get(i) + " ");
				
		} 

		// 162) Write a Java program that finds numbers greater than the average of an array.
		
		/** 
		* Jul 6, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		* @see
		* 
		* Observaciones: Uso de Streams ( LO IMPLEMENTO EN FORMA DECLARATIVA CON STREAMS -> (JAVA8+) )
		* 
		* 	things to improve (if there is time) -> 
		* 
		* (CLAVE) 
		* 	TDD - 1ero caso ideal yl <>s inputs posibles -alternativas -Robustez.
		*/

		public void findNumbersGreaterThanAverageInIntArray() {
			/** (TDD)
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: op1) prog imperativa: recorro todo el arr acum la suma yl lo divido x la cant de elems xa calcular el promedio. 
			*															luego lo recorro de nuevo y comparo contra ese nro promedio.
			*								 op2) prog declarativa: (Streams / rx api) lo desarrollo con Streams. (prog simil sql simil linux shell )  
			*/
			//a) in: 	
			
				int[] iArrIn = {1, 4, 17, 7, 25, 3, 100};
					
			//b) alg: -> op2: declarativa ( Streams ) 
																						printVec(iArrIn);
				double promedio = 	Arrays.stream(iArrIn).average().orElse(0); 			System.out.println("Promedio: " + promedio);
																						System.out.println("ints > a " + promedio + ":" );
				Arrays.stream(iArrIn).filter(x-> x>promedio).forEach(System.out::println);
				
			//c) out: PROMEDIO : 22.42857142.. (22.4 aprox) -> Elems q cumplem, post alg (out): 25 y 100  ( FUNCIONA ) TODO mas casos alt, robust, c/ JUNIT TEST!   

		}
		
		
		// 167)	Write a Java program to move every zero to the right side of a given array of integers.

		//		(	original array: [0, 3, 4, 0, 1, 2, 5, 0] -> 	result: [3, 4, 1, 2, 5, 0, 0, 0]	)
		
		/** 
		* Jul 7, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Obs: podria hacerlo generico xa q sirva tmb xa moverlos a la izq ? -> mepa q no.. me cambia mucho el alg. sera otro <> !!
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void move0sToRightInArr() {	 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y
			*									en el caso que no ( xq no hay mas numeros <>s de 0 ( osea solo quedan todos 0s a la der ) ent un break total del 
			*									ciclo ppal.  
			*/
									/* 	(L)earning: 
									* 	
									* 	Hay veces q es conveniente usar break dentro de un bucle como condicion de fin del bucle? o nunca hay q usar break en bucles?
									* 
									*	En Java, la sentencia break se utiliza para finalizar la ejecucin de un bucle de manera prematura, incluso si la condicin del 
									*	bucle an no se ha cumplido. Aunque el uso de break en bucles puede ser conveniente en algunas situaciones, se considera una 
									*	prctica menos comn y generalmente se recomienda evitarlo cuando sea posible.
										
										Aqu hay algunas consideraciones sobre el uso de break en bucles en Java:
										
										Legibilidad del cdigo: El uso de break puede dificultar la lectura y comprensin del cdigo,ya q puede saltar abruptamente fuera 
										del bucle y hacer que el flujo del programa sea menos evidente. Esto puede hacer qel cdigo sea ms difcil de mantener y depurar.
										
										Diseo estructurado: El uso de break puede romper el principio de diseo estructurado, que busca reducir la complejidad y mejorar 
										la claridad del cdigo. Al utilizar break, se interrumpe la ejecucin normal del bucle y se puede perder la estructura lgica y la 
										coherencia del cdigo.
										
										Alternativas ms claras: En muchos casos, se pueden utilizar otras tcnicas para lograr el mismo resultado sin usar break. Por ejemplo, 
										utilizando una variable de control en la condicin del bucle o utilizando una instruccin return para salir de un mtodo si es necesario.
										
										Aunque existen situaciones en las q	el uso de break puede ser justificado y conveniente,como el procesamiento anticipado de datos 
										o la terminacin temprana en casos excepcionales, se recomienda utilizarlo con moderacin y asegurarse de qsea la mejor opcin en 
										trminos de legibilidad y mantenibilidad del cdigo.
										
										En general, es recomendable seguir las mejores prcticas de programacin y utilizar break en bucles solo cuando sea absolutamente 
										necesario y no haya alternativas ms claras y estructuradas.  	* */
			
			//a) in:  				( ex:  [0, 3, 4, 0, 1, 2, 5, 0] )
			
					int[] iArrInt = {3, 4, 1, 2, 5, 0, 0, 0};

			//b) alg: 		Recorro el array ( c/elem) c/1 for ( total dentro tengo un proced (bucle interno) q recorre los sig xa ver si seguir o no, y en el caso que  
			//	 ---			no ( xq no hay mas numeros <>s de 0 , osea solo quedan todos 0s a la der ) ent un break total del ciclo ppal.  
						
					
					for (int i = 0; i < iArrInt.length; i++) {
						if ( (iArrInt[i]==0) && (i!=iArrInt.length -1) ) {	// si debo tratarlo ( si es cero y no es el ultimo ) .. 
							
							int posSigTmp = tomarSigPosElemNoCero(i+1, iArrInt) ;
							if ( posSigTmp != -1 ){	//	si el sig o posteriores (osea desde el sig) qda/hay alguno <> de 0 ..   
								swapValuesInArr(i, posSigTmp, iArrInt);
							}
									
						}
					}
						

			//c) out: ex: [3, 4, 1, 2, 5, 0, 0, 0] 
					printVec(iArrInt);
		}

		// 169)	Write a Java program to reverse a sentence (assume a single space between two words) without reverse every word.

		//		-> 	Input a string: The quick brown fox jumps over the lazy dog		-> 		Result: dog lazy the over jumps fox brown quick The
		
		/** 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/

		public void reverseString() {	//TODO parametrizar + darle robustez + test de unidad con junit 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: tomo el iPos init q es 0 y el iPosFin q es len-1 , los swapeo y i++ f++ mientras i<f 
			*									(si son iguales o se pasa (>) no swapea mas) . 
			*							
			*							(L)earning Ver q facil se hace todo con modul funcs helpers. dividir el problema!
			*							(L)earning ver q dibuj + pens! y alg pseudo claro! incluso con caso de prueba en hoja asi nomas
			*									luego lo cerr codeando pero era casi eso mismo! 
			*								y AL NO FUNCAR DE 1, DEBUG ayuda xa rapidez boludeces ajustes!!!!!!!!!!!	
			*/							

			//a) in:
				
				String strIn = "The quick brown fox jumps over the lazy dog";	
				
				System.out.println("String original a ser revertido:" + strIn);
				
			//b) alg:
			
				char[] chrArr= strIn.toCharArray();
				

				int iPosI = 0; int iPosF = strIn.length() -1; 
				
				while ( iPosI < iPosF) {
					swapValuesInArr(iPosI, iPosF, chrArr);
					//iPosI=iPosI+1; iPosF=iPosF-1;//++iPosI; ++iPosF;//iPosI++; iPosF--;
					//iPosI++; iPosF--; funca xq suma de una  
					++iPosI; --iPosF; // tmb funca (**va**)
									  // (L) pre vs post: la dif es cuando van e/() o en exprs o en bucles etc! (**va**)
				}
				
				String strOut=String.valueOf(chrArr);
				
				//c) out: "dog lazy the over jumps fox brown quick The"I
				
				System.out.println("Reversed String Imperative way (a mano) -> " + strOut);
		}
		
		//(**viene**)  Pre vs post ->  	++var 	Vs 	var++ 
		//---------------------------------------------------------------
		//(L)earning:  PREFIX VS POSTFIX	( mepa q la dif es cuando van e/() o en exprs o en bucles etc!!! creo yo..)
		//			   ------ -- -------
		// ver mi ej q no hace dif, tmpoco como cond en fors pero entre () pasado a methodos etc si:
		//ej:  
		//	let i:number = 2;
        //	let j:number = 5;
        
        //	console.log('El valor de i es ' + i++ ) // El valor de i es 2
        //	console.log('El valor de i es ' + i ) // El valor de i es 3

        //	console.log('El valor de j es ' + ++j ) // El valor de j es 6
        //	console.log('El valor de j es ' + j ) // El valor de j es 6
        
		//prefijo vs postfijo ( ++var vs var ++ ) 
		
		//Si te refieres a construcciones de este tipo:
		
		// public static void main(String[] args) {	//	( es = )	!!!
		
		//    for (int i = 0; i < 10; ++i) {
		//        System.out.println(i);
		//    }
		//    for (int i = 0; i < 10; i++) {
		//        System.out.println(i);
		//    }
		// }
		
		//	-> entonces no hay diferencia. !!!
		//( si vemos el bytecode en ambos casos el inc en ambos casos se ejecuta luego de la sentencia println) 
		//	( En ambos casos, justo despus de invocar el println ( invokevirtual #3 ), se incrementa la variable 1 (en el cdigo es i para ambos casos) en 1() ) 
		
		// ..pero , No obstante, si te refieres a algo como esto:

		//	public static void main(String[] args) {	//	( es <> )	!!!
		
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(i++);
		//	    }
		//	    for (int i = 0; i < 10;) {
		//	        System.out.println(++i);
		//	    }
		//	}
		
		// -> entonces s hay diferencia. !!!
		// Explicacion: Si analizamos el bytecode:
		// En el primer caso, primero se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1. Despus se incrementa esta variable en 1. Vase el iinc 1, 1.

		// En el segundo caso, primero se incrementa el valor de la variable 1 (i) en 1, 
		// Vase el iinc 1, 1. Luego se carga el valor de la variable 1 (i) para ser usado en el 
		// println. Vase el iload_1
		
		// OTRO EJEMPLO:
		
		//Cuando se usan los operadores prefijos, se evala la expresin y despus se utiliza.
		//Cuando se usan los operadores postfijos, se usa la expresin sin evaluar y despus se evala.
		//Por ejemplo, si usamos operadores prefijos:

		// int a = 1;  int b = 2; 	int c = 3;
		// int prefijo = (++a)+(- -b)+(++c);		//aca hace a+1 yl pasa a lo sig! mismo b-1 y c+1
		
		//El valor que almacena la variable prefijo es 7. ( osea 2 + 1 + 4 ) !!!!!!!!!! 
		
		//--------------------------------------------------------------------------------------- 
		
		//175. Write a Java program to delete a specified node in the middle of a singly linked list.
		//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

		//	Sample Singly linked list: 10->20->30->40->50
			//	Delete the fourth node i.e. 40
			//	Result: 10->20->30->50


		/**																	 
		* Jul 8, 2023	
		* Author: Carlos Esteban Gil.-
		* 
		* Description:	
		* 
		* @param parametro1 Descripcin del primer parmetro.
		* @param parametro2 Descripcin del segundo parmetro.
		* @return Descripcin del valor de retorno.
		* @throws ExcepcionTipo Descripcin de la exception
		*
		* Observaciones: Este ej se puede obviar .. 
		* 
		*	things to improve (if there is time) -> 
		* 
		*/
		
		public void synglyList() { 
			/* TDD		( - to + . by main goal. first common-case then <>s input )	
			*
			*	Analisis / Objetivo:	obj: 
			*	Entrada:				in:  
			*	Salida:					out: 
			*	Proceso / PseudoCode: 	alg: 
			*/

			//a) in:	

			//b) alg:
			  head = new ListNode(10);//this.new ListNode(10); (L)earning:  a veces las inner clases debenser accesibles como aca yreferenciarse /usarse de esta manera pero este no era el caso.. 
			  head.next = new ListNode(20); // new ListNode(20); 
			  head.next.next = new ListNode(30);
			  head.next.next.next = new ListNode(40);
			  head.next.next.next.next = new ListNode(50);
			  ListNode p = head;
			  System.out.println("Original Linked list:");
			  printList(p);
			  System.out.println("\nAfter deleting the fourth node, Linked list becomes:");
			  deleteNode(head.next.next.next);
			  p = head;
			  printList(p);

			//c) out:

		}
					
		/* (L)earning Clase ListNode:  ( esto es muy algoritmo y est de datos. muy bajo nivel. solo si me interesa como se almacena internamente cada elem 
		 * 										( cambiarlo etc y no un impl automatica )
					  ----- --------
			SABER:!! -> la clase Node para una lista simplemente enlazada (singly linked list) no est definida en la biblioteca estndar de Java!!!!!!!!! 
			. En realidad, la implementacin de una lista simplemente enlazada, incluyendo la definicin de la clase Node, es un concepto independiente del lenguaje y puede ser implementado en cualquier versin de Java.

			La clase Node es generalmente definida por los programadores cuando implementan una lista simplemente enlazada en Java. 		  
			Si necesitas implementar tu propia estructura de datos, como una lista enlazada personalizada, deberas usar ListNode. Esto ocurre cuando 
			necesitas un mayor control sobre cmo se almacenan y manipulan los elementos en la lista.
	
			Si solo necesitas una coleccin de elementos y no necesitas implementar tu propia estructura de datos, es mejor utilizar las 
			implementaciones existentes de List como ArrayList o LinkedList. Estas implementaciones te brindan mtodos y funcionalidades listos para 
			usar, como agregar, eliminar y acceder a elementos de manera eficiente.
	
			En resumen, si necesitas crear una lista enlazada personalizada, usa ListNode. Si solo necesitas una coleccin de elementos, utiliza las 
			implementaciones existentes de List en Java. 
		*/
		
		//public static ListNode head = new ListNode(10);
		 class ListNode {
			 int val;
			 ListNode next;

			 ListNode(int val) {
			  this.val = val;
			  this.next = null; 
			  }
		}
		public static ListNode head; 						
		
		 static void printList(ListNode p) {

			  while (p != null) {
			   System.out.print(p.val);
			   if (p.next != null) System.out.print("->"); 
			   p = p.next;
			  }
			 }
			
	 public static void deleteNode(ListNode node) {
		  if (node.next != null) {
		   int temp = node.val;
		   node.val = node.next.val;
		   node.next.val = temp;

		   node.next = node.next.next;
		  } else {
		   ListNode p = head;
		   while (p.next.val != node.val) {
		    p = p.next;
		   }
		   p.next = null;
		  }
		 }
		
	//--------------------------------------------------------------------------------------- 
	//175.Write a Java program that partitions an array of integers into even and odd numbers
	//		( con singly (q significa individualmente enlazada, me indica q utilice ListNode (<>s instancias de nodos eblazados con next a mano x mi )

	//	Sample: Original array:  [7, 2, 4, 1, 3, 5, 6, 8, 2, 10]
	//			Result 	 array:	 [10, 2, 4, 2, 8, 6, 5, 3, 1, 7]
	 
	 /** 
	* Jul 13, 2023	
	* Author: Carlos Esteban Gil.-
	* 
	* Description:	pares yl impares : Toma un arr de ints desordenados y deja todos los pares 1ero yl todos los impares siguiendolos hasta el final ( si hay .. )
	* 
	* @param parametro1 Descripcin del primer parmetro.
	* @param parametro2 Descripcin del segundo parmetro.
	* @return Descripcin del valor de retorno.
	* @throws ExcepcionTipo Descripcin de la exception
	*
	* Observaciones:
	* 
	*	things to improve (if there is time) -> 
	* 
	*/

	public void evenThenOddsArr() { 
		/* TDD		( - to + . by main goal. first common-case then <>s input )	
		*
		*	Analisis / Objetivo:	obj: 
		*	Entrada:				in:  
		*	Salida:					out: 
		*	Proceso / PseudoCode: 	alg: creo un vec rtante de mismo size (lenght) q el orig xq acomodar no implica quitar ni agregar osea no modif la cant elems ser =,
		*								 mi alg: tomo el 1ero actual y lo comparo contra el ultimo actual (ej el 1ero contra el ulti), el q es par lo meto en el vec r,
		*											y el q es impar lo meto en el vec de r pero en la pos  lenght - cantImpares (si habia cero ent ser la pos ulti y asi)
		*										 En resumen voy barriendo el arr de a pares (el i actual y su equidistante desde el final) yhago esas comparaciones qdije,
		*											luego iact++ y contra el sig elem corresp (su par, osea lenght - iactual (el new) ) y misma comparacion..
		*											cond de fin del bucle: si pos iactual > ent fin perooo si es = (xq # elems en vec era impar) ent lo meto a ese solo en
		*											el vec r tmb con la misma logica de donde le corresponda segun sea par o impar (en ese indice) .fin. 
		*/											// (L) Recordar q arr.length me da la CANTIDAD de elems de array (no la pos del ulti elem, esa seria length - 1) !!! 

		//a) in:
		
		int[] iArrIn = {7, 2, 4, 1, 3, 5, 6, 8, 2, 10};

		//b) alg:
		
		int[] iArrOut = new int[iArrIn.length]; // como ordenar no implica quitar ni agregar entonces van a tener siempre el mismo tamao

		int iPosActual=0; int IposPareja; int iElemActual=0; int iElemPareja=0; int iCantImpares=0; //(L)earning: mejor vars x/c/cosa asi qda mas claro el code
		
		int tamaoArrayOrig = iArrIn.length;
		
		
		IposPareja=iArrIn.length-1; // pos del ultimo elem del array 
		
		while ( tamaoArrayOrig >=1) ( iPosActual	<=	IposPareja ) {
			
		}
		
		//c) out:

	}
	 

	//---------------------------------------------------------------------------------------
		// TODO template basico para javadoc corto tipo author descripcion (objetivo y funcionamiento basico pseudo ) ,inputs, return .. lo basico osea 
		//	(desc obj e ypseudoidea, ins, y out)  TODO Probarlo! TODO opcional darle robustez
		//---------------
		// si hay retorna la pos del elem en el array q le pasen desde la pos inicial q le pasen sino pos -1 que ya no queda ninguno distinto de cero
		// retorna: el indice del elem distinto de 0 si hay, o -1 si no hay mas elems distintos de 0 ( siempre por delante de la pos init que recibe )
		private int tomarSigPosElemNoCero(int posInit, int[] iArr) {
			int r= -1;
			for (int i = posInit; i<iArr.length; i++) {
				if ( iArr[i] != 0 ) {
					r=i;
					break;
				} 
			}
			return r;
		}
		
		//----
		// Swapea 2 valores. usa una var tmp xa guardar el val de uno de ellos. 
		//	luego el otro valor lo mete en el lugar del q tngo backup yl en el lugar del aun no reemplazo meto el backup value
		// no devuelve nada porque los arrays comunes pasan x ref: 
		
		//(L)earning: En Java, los arrays comunes se pasan por referencia a un mtodo. Esto significa que cuando pasas un array 
		//				como argumento a un mtodo, ests pasando una referencia al array original y no una copia del mismo.
		//				Como resultado, el mtodo que recibe el array puede modificar su contenido y esos cambios se reflejarn 
		//				en el array original fuera del mtodo. No se crea una nueva copia del array en memoria.
		
		public void swapValuesInArr(int iPos1, int iPos2, int[] iArr) {
			int iValueTmp = iArr[iPos2];
			iArr[iPos2]=iArr[iPos1];  
			iArr[iPos1]=iValueTmp;
		}

		// x ahora sobrecargo el metodo para mantener la misma interfaz de uso de api TODO: ver si podria hacerse 1 solo con generics.. xq el algoritmo es el mismo!
		public void swapValuesInArr(int iPos1, int iPos2, char[] cArr) {
			char chrValueTmp = cArr[iPos2];
			cArr[iPos2]=cArr[iPos1]; 
			cArr[iPos1]=chrValueTmp;
		}

		
		//TODO Ojo podria hacer un imprimir un vector de cualquier tipo de numeros ( usando generics! ) o incluso + gral de objs 
		//			e  incluso el mismo printMat q funque para una sola dim si se puede sino ya fue 
		public static void printVec(int[] iVec) {
			System.out.println();
			for (int i = 0; i < iVec.length; i++) {
				System.out.print(iVec[i] + " ");
			if ( i == ( iVec.length -1) ) System.out.print("\n");
			}
		}
		
// ------------ Cosas extras:
				
		/* -----------------
		 * TEMPLATES CUSTOMS para insert comment mios con key combination custom y me tmb!!				(*viene)   
		 * -----------------
		 * PASOS:
		 * -----
		 * En Eclipse, ve al men "Window" y selecciona "Preferences" (o "Preferencias" en sistemas macOS).
		 * 
		 * En la ventana de preferencias, expande la categora "Java" y selecciona "Editor" y luego "Templates" (o "Plantillas").
		 * 
		 * En la lista de plantillas, haz clic en "New" (o "Nuevo") para crear una nueva plantilla.
		 * 
		 * En el campo "Pattern" (o "Patrn"), ingresa el comentario personalizado que deseas insertar. Puedes incluir informacin dinmica utilizando variables
		 * especiales, como ${user} para el nombre del autor o ${date} para la fecha  actual.
		 * 
		 * En el campo "Name" (o "Nombre"), ingresa un nombre descriptivo para la plantilla.
		 * 
		 * En el campo "Context" (o "Contexto"), selecciona "Java" para limitar la plantilla a ser utilizada solo en archivos Java.
		 * 
		 * Haz clic en "OK" para guardar la plantilla.

		 * Hasta ahi todo bien, lo sig no!: ------ 
		 * 
		 * Ahora, ve a la pestaa "Keys" (o "Teclas") en la ventana de preferencias.
		 * 
		 * En el campo "Filter text" (o "Texto de filtro"), ingresa un texto corto que desees utilizar como atajo, por ejemplo, "cmnt".
		 * 
		 * Haz clic en el campo "Binding" y presiona las teclas que deseas usar como atajo, por ejemplo, "Ctrl + Alt + C".
		 * 
		 * En el campo "When" (o "Cundo"), selecciona "In Windows" o "In Dialogs and Windows" para habilitar el atajo en el editor de cdigo.
		 * 
		 * Haz clic en "Apply" (o "Aplicar") y luego en "OK" para guardar los cambios.
		 * 
		 * ---------- 
		 * seguir desde aca (esto si) : ( luego de hyaber creado el temlate lo inserto escribiendo su nombre y con ctrl + espace xa q el editor de eclipse lo autocomplete

		 * 	Mis disculpas por la confusin. Parece que hay una confusin en la terminologa. La opcin "Insert Template" no est disponible directamente en Eclipse sin complementos adicionales. Lamento la informacin incorrecta proporcionada anteriormente.

			Para crear un atajo para insertar una plantilla personalizada en Eclipse sin complementos adicionales, puedes seguir estos pasos:
			
			Abre Eclipse y ve al men "Window" (Ventana) en la barra de navegacin superior.
			Selecciona "Preferences" (Preferencias) en el men desplegable. Esto abrir la ventana de preferencias de Eclipse.
			En la ventana de preferencias, expande la categora "Java" en el panel izquierdo y selecciona "Editor" debajo de ella.
			En la lista de opciones del editor, haz clic en "Templates" (Plantillas).
			Aparecer una lista de plantillas de cdigo existentes. Haz clic en el botn "New" (Nuevo) para crear una nueva plantilla.
			En el campo "Pattern" (Patrn), escribe el cdigo de tu plantilla personalizada. Puedes utilizar variables como ${var}, ${word_selection} o ${line_selection} para hacerla ms flexible.
			En el campo "Name" (Nombre), proporciona un nombre descriptivo para tu plantilla.
			Haz clic en "OK" (Aceptar) para guardar la plantilla.
			Para insertar la plantilla personalizada utilizando un atajo, puedes seguir estos pasos adicionales:
			
			Abre el archivo en el editor de Java donde deseas insertar la plantilla.
			Escribe el nombre de la plantilla que creaste anteriormente. Por ejemplo, si el nombre de la plantilla es "mytemplate", escribe "mytemplate".
			Presiona la combinacin de teclas "Ctrl + Espacio" para activar la funcin de autocompletado de Eclipse.
			En la lista de opciones que aparece, selecciona la plantilla deseada y presiona "Enter" para insertarla en el cdigo.
			No hay una opcin de atajo dedicada para insertar plantillas directamente en Eclipse sin complementos adicionales. Sin embargo, puedes usar el autocompletado de Eclipse presionando "Ctrl + Espacio" para acceder rpidamente a tus plantillas personalizadas y seleccionar la que deseas utilizar. 
		 */
	
	
	// Saber q xa insertar un metodo el template x defecto de java xa esta accion se llama private_method ( asi q si lo escribo + ctrl + space (autocomplete) lo tengo)
	//	y saber q esto est en windows - preferences - java - editor - content assist - templates (Y DEBO EDITARLO XA TILDAR EL CHECK DE AUTO-INSERT (apagado x default)) 
	/** 
	* Jun 24, 2023	
	* Author: Carlos Gil
	* 
	* Description:	
	* 
	*/
	private void name() {
		
	}
	
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1798)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5155)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4778)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5034)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-13 13:24:12.626
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1798)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5155)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4778)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5034)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-13 13:24:12.627
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1798)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5155)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:406)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4778)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5034)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3643)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 13:26:58.330
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:26:58.333
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 13:26:58.338
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 14:26:07.826
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 14:26:07.849
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 14:26:07.853
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:00:07.564
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:00:07.570
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:00:07.573
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:02:08.922
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:02:08.925
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:02:08.928
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:03:38.995
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:03:38.998
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:03:39.000
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:52:24.562
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:52:24.592
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:52:24.598
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:53:18.840
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:18.842
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:18.844
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 15:53:56.862
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:56.865
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 15:53:56.868
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 16:02:44.036
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:02:44.046
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:02:44.051
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-07-13 16:05:10.531
!MESSAGE Unexpected URLConnection defaultUseCaches enabled

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:05:10.534
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-13 16:05:10.537
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-24 18:45:20.275 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-24 18:45:29.750
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-24 18:45:29.750
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6207145c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-24 18:45:29.750
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a259f6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ccf6114,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-24 18:45:36.321
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:08:24.875
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:08:24.889
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:09:23.362
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:09:23.370
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:11.023
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:11.027
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:22.774
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:22.779
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:47.510
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:12:47.513
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:13:59.776
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:13:59.780
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:14:20.892
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:14:20.896
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:33:07.864
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:33:07.868
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:47:53.963
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:47:53.966
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:48:29.022
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 19:48:29.025
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 21:46:32.660
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-24 21:46:32.664
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 14:26:25.538
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 14:26:25.546
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 17:05:30.704
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-25 17:05:30.718
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-07-27 15:05:59.405 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-27 15:07:09.711
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-27 15:07:09.711
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a878778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-27 15:07:09.711
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6207145c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a259f6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-27 15:07:19.798
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-27 21:45:28.400
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-07-27 21:45:28.440
!MESSAGE Using platform encoding (Cp1252 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-08-03 20:14:55.528 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-03 20:15:03.601
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-03 20:15:03.601
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a878778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eabfad5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-03 20:15:03.601
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6207145c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a259f6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-03 20:15:13.252
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:17.404
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:18.606
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:19.050
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-03 20:16:20.885
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.loadMetadataRepository(ProvisioningContext.java:233)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedMetadataRepositories(ProvisioningContext.java:211)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getMetadata(ProvisioningContext.java:299)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.gatherAvailableInstallableUnits(SimplePlanner.java:357)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getSolutionFor(SimplePlanner.java:434)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getProvisioningPlan(SimplePlanner.java:520)
	at org.eclipse.equinox.internal.p2.operations.PlannerResolutionJob.runModal(PlannerResolutionJob.java:80)
	at org.eclipse.equinox.p2.operations.ProfileChangeOperation.resolveModal(ProfileChangeOperation.java:118)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveModal(ProfileChangeOperationComputer.java:367)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolve(ProfileChangeOperationComputer.java:356)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveInstall(ProfileChangeOperationComputer.java:282)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.run(ProfileChangeOperationComputer.java:180)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1000 2023-08-03 20:16:20.886
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:20.889
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:16:31.746
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/content.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:00.462
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:01.673
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:01.975
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-03 20:17:04.129
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.load(CompositeArtifactRepository.java:496)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.addChild(CompositeArtifactRepository.java:177)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.<init>(CompositeArtifactRepository.java:99)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory.load(CompositeArtifactRepositoryFactory.java:120)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedRepository(ProvisioningContext.java:189)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedArtifactRepositories(ProvisioningContext.java:163)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getArtifactRepositories(ProvisioningContext.java:149)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.getArtifactRepositories(DownloadManager.java:110)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:95)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1000 2023-08-03 20:17:04.129
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:04.130
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-03 20:17:14.044
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/artifacts.xml.xz

!ENTRY org.eclipse.equinox.p2.engine 4 4 2023-08-03 20:17:36.105
!MESSAGE An error occurred while collecting items to be installed
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2023-08-03 20:17:36.105
!MESSAGE session context was:(profile=C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse, phase=org.eclipse.equinox.internal.p2.engine.phases.Collect, operand=, action=).
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2023-08-03 20:17:36.105
!MESSAGE Cannot invoke "org.eclipse.equinox.internal.p2.repository.Transport.download(java.net.URI, java.io.OutputStream, org.eclipse.core.runtime.IProgressMonitor)" because the return value of "org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getTransport()" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.equinox.internal.p2.repository.Transport.download(java.net.URI, java.io.OutputStream, org.eclipse.core.runtime.IProgressMonitor)" because the return value of "org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getTransport()" is null
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:748)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:672)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifacts(SimpleArtifactRepository.java:864)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.getArtifacts(CompositeArtifactRepository.java:362)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.fetch(DownloadManager.java:127)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:98)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-08-17 13:00:09.972 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-17 13:00:18.517
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:00:18.517
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c83ed77,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d271a54,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:00:18.517
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ff8e744,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@409395b9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-17 13:00:26.607
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:03:51.492
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at java.base/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:45)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:194)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:03:51.495
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:35)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:194)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:03:51.496
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:35)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:194)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:36.117
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:37.328
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:37.632
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:04:39.775
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.loadMetadataRepository(ProvisioningContext.java:233)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedMetadataRepositories(ProvisioningContext.java:211)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getMetadata(ProvisioningContext.java:299)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.gatherAvailableInstallableUnits(SimplePlanner.java:357)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getSolutionFor(SimplePlanner.java:434)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.getProvisioningPlan(SimplePlanner.java:520)
	at org.eclipse.equinox.internal.p2.operations.PlannerResolutionJob.runModal(PlannerResolutionJob.java:80)
	at org.eclipse.equinox.p2.operations.ProfileChangeOperation.resolveModal(ProfileChangeOperation.java:118)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveModal(ProfileChangeOperationComputer.java:367)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolve(ProfileChangeOperationComputer.java:356)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveInstall(ProfileChangeOperationComputer.java:282)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.run(ProfileChangeOperationComputer.java:180)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.equinox.p2.metadata.repository 4 1000 2023-08-17 13:04:39.776
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:39.778
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:04:47.891
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/content.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:22.947
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:24.004
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml.xz, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:24.317
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:05:26.532
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.fail(AbstractRepositoryManager.java:405)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.fail(CachingRepositoryManager.java:386)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:277)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.load(CompositeArtifactRepository.java:496)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.addChild(CompositeArtifactRepository.java:177)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.<init>(CompositeArtifactRepository.java:99)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory.load(CompositeArtifactRepositoryFactory.java:120)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor53.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedRepository(ProvisioningContext.java:189)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedArtifactRepositories(ProvisioningContext.java:163)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getArtifactRepositories(ProvisioningContext.java:149)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.getArtifactRepositories(DownloadManager.java:110)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:95)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.artifact.repository 4 1000 2023-08-17 13:05:26.533
!MESSAGE No repository found at http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:26.534
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:05:33.603
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/artifacts.xml.xz

!ENTRY org.eclipse.equinox.preferences 4 4 2023-08-17 13:05:55.154
!MESSAGE Exception saving preferences to: C:/Users/carlo/.p2/org.eclipse.equinox.p2.engine/profileRegistry/C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile/.data/.settings/org.eclipse.equinox.p2.artifact.repository.prefs.
!STACK 0
java.nio.file.NoSuchFileException: C:\Users\carlo\.p2\org.eclipse.equinox.p2.engine\profileRegistry\C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile\.data\.settings\org.eclipse.equinox.p2.artifact.repository.prefs.bak
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileCopy.move(WindowsFileCopy.java:326)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.move(WindowsFileSystemProvider.java:293)
	at java.base/java.nio.file.Files.move(Files.java:1426)
	at org.eclipse.core.internal.preferences.EclipsePreferences.write(EclipsePreferences.java:289)
	at org.eclipse.core.internal.preferences.EclipsePreferences.save(EclipsePreferences.java:1066)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences.doSave(ProfilePreferences.java:141)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences$SaveJob.run(ProfilePreferences.java:54)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.engine 2 0 2023-08-17 13:05:55.155
!MESSAGE Exception saving profile preferences
!STACK 0
org.osgi.service.prefs.BackingStoreException: Exception saving preferences to: C:/Users/carlo/.p2/org.eclipse.equinox.p2.engine/profileRegistry/C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile/.data/.settings/org.eclipse.equinox.p2.artifact.repository.prefs.
	at org.eclipse.core.internal.preferences.EclipsePreferences.write(EclipsePreferences.java:296)
	at org.eclipse.core.internal.preferences.EclipsePreferences.save(EclipsePreferences.java:1066)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences.doSave(ProfilePreferences.java:141)
	at org.eclipse.equinox.internal.p2.engine.ProfilePreferences$SaveJob.run(ProfilePreferences.java:54)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.nio.file.NoSuchFileException: C:\Users\carlo\.p2\org.eclipse.equinox.p2.engine\profileRegistry\C__!_CARLOS ESTEBAN GIL - VIDA COMPLETA ACTIVIDADES - NO FOTOS_SISTEMAS_IDEs & Editors_server - side_java_java-2022-06_eclipse.profile\.data\.settings\org.eclipse.equinox.p2.artifact.repository.prefs.bak
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileCopy.move(WindowsFileCopy.java:326)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.move(WindowsFileSystemProvider.java:293)
	at java.base/java.nio.file.Files.move(Files.java:1426)
	at org.eclipse.core.internal.preferences.EclipsePreferences.write(EclipsePreferences.java:289)
	... 4 more
!SESSION 2023-08-17 13:06:18.265 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=16
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.tm.terminal.connector.local 4 0 2023-08-17 13:06:23.734
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.local [336]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
              org.eclipse.tm.terminal.view.core [509]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.connector.process; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.connector.process; bundle-version="4.8.100.202204200013"; singleton:="true"
       org.eclipse.tm.terminal.connector.process [337]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.connector.process 4 0 2023-08-17 13:06:23.738
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.process [337]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
              org.eclipse.tm.terminal.view.core [509]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.connector.ssh 4 0 2023-08-17 13:06:23.739
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.ssh [338]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.connector.telnet 4 0 2023-08-17 13:06:23.742
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.connector.telnet [339]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="4.5.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.5.0"; resolution:="optional"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.wildwebdeveloper.xml 4 0 2023-08-17 13:06:23.782
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.wildwebdeveloper.xml [376]
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.languageconfiguration; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.languageconfiguration; bundle-version="0.5.5.202305171341"; singleton:="true"
       org.eclipse.tm4e.languageconfiguration [512]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.4"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.ui; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.ui; bundle-version="0.6.4.202305161247"; singleton:="true"
       org.eclipse.tm4e.ui [514]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry; bundle-version="0.3.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient5 4 0 2023-08-17 13:06:23.786
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient5 [498]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient5.win32 4 0 2023-08-17 13:06:23.790
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient5.win32 [499]
  Unresolved requirement: Import-Package: org.eclipse.ecf.provider.filetransfer.httpclient5; version="[1.0.0,2.0.0)"
    -> Export-Package: org.eclipse.ecf.provider.filetransfer.httpclient5; bundle-symbolic-name="org.eclipse.ecf.provider.filetransfer.httpclient5"; bundle-version="1.1.0.v20230423-0417"; version="1.0.0"
       org.eclipse.ecf.provider.filetransfer.httpclient5 [498]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Import-Package: org.eclipse.ecf.internal.provider.filetransfer.httpclient5; version="[1.0.0,2.0.0)"
    -> Export-Package: org.eclipse.ecf.internal.provider.filetransfer.httpclient5; bundle-symbolic-name="org.eclipse.ecf.provider.filetransfer.httpclient5"; bundle-version="1.1.0.v20230423-0417"; version="1.0.0"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.linuxtools.docker.core 4 0 2023-08-17 13:06:23.792
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.linuxtools.docker.core [502]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.0.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.linuxtools.docker.editor.ls 4 0 2023-08-17 13:06:23.794
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.linuxtools.docker.editor.ls [504]
  Unresolved requirement: Require-Bundle: org.eclipse.wildwebdeveloper.embedder.node
    -> Bundle-SymbolicName: org.eclipse.wildwebdeveloper.embedder.node; bundle-version="1.0.2.202212140804"
       org.eclipse.wildwebdeveloper.embedder.node [515]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.ui; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.ui; bundle-version="0.6.4.202305161247"; singleton:="true"
       org.eclipse.tm4e.ui [514]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry; bundle-version="0.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.linuxtools.docker.ui 4 0 2023-08-17 13:06:23.800
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.linuxtools.docker.ui [505]
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.0.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.linuxtools.docker.core; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.linuxtools.docker.core; bundle-version="5.7.0.202206072042"; singleton:="true"
       org.eclipse.linuxtools.docker.core [502]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="4.0.0"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.ui; bundle-version="4.1.0"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.ui; bundle-version="4.11.100.202304132101"; singleton:="true"
       org.eclipse.tm.terminal.view.ui [510]
         Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
           -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.control 4 0 2023-08-17 13:06:23.801
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.control [508]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.view.core 4 0 2023-08-17 13:06:23.802
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.view.core [509]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm.terminal.view.ui 4 0 2023-08-17 13:06:23.815
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm.terminal.view.ui [510]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.control; bundle-version="[5.2.0,6.0.0)"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.control; bundle-version="5.4.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.control [508]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm.terminal.view.core; bundle-version="[4.8.0,5.0.0)"
    -> Bundle-SymbolicName: org.eclipse.tm.terminal.view.core; bundle-version="4.9.100.202303140100"; singleton:="true"
       org.eclipse.tm.terminal.view.core [509]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.core 4 0 2023-08-17 13:06:23.816
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.core [511]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.languageconfiguration 4 0 2023-08-17 13:06:23.817
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.languageconfiguration [512]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.4"
    -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.ui; bundle-version="0.6.4"
    -> Bundle-SymbolicName: org.eclipse.tm4e.ui; bundle-version="0.6.4.202305161247"; singleton:="true"
       org.eclipse.tm4e.ui [514]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.registry 4 0 2023-08-17 13:06:23.818
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.registry [513]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
    -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
       org.eclipse.tm4e.core [511]
         Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.tm4e.ui 4 0 2023-08-17 13:06:23.819
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.tm4e.ui [514]
  Unresolved requirement: Require-Bundle: org.eclipse.ui.trace; resolution:="optional"
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.registry; bundle-version="0.6.3"
    -> Bundle-SymbolicName: org.eclipse.tm4e.registry; bundle-version="0.6.3.202303141648"; singleton:="true"
       org.eclipse.tm4e.registry [513]
         Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
           -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"
              org.eclipse.tm4e.core [511]
                Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"
  Unresolved requirement: Require-Bundle: org.eclipse.tm4e.core; bundle-version="0.5.2"
    -> Bundle-SymbolicName: org.eclipse.tm4e.core; bundle-version="0.5.4.202305171341"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.wildwebdeveloper.embedder.node 4 0 2023-08-17 13:06:23.819
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.wildwebdeveloper.embedder.node [515]
  Unresolved requirement: Require-Capability: osgi.ee; filter:="(&(osgi.ee=JavaSE)(version=17))"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1847)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1840)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1781)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1745)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1667)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2023-08-17 13:06:32.635
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:06:32.635
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@195cbf5e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cb82b09,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-17 13:06:32.635
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49665f92,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@b68932b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-17 13:06:40.728
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\carlo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2023-08-17 13:06:40.785
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.tm.terminal.view.ui.TerminalsView" id and the "Terminal" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2023-08-17 13:06:40.786
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.tcf.te.ui.terminals.TerminalsView" id and the "Terminals (Old)" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:07:28.048
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at java.base/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:45)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:231)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:07:28.050
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:35)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:231)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:07:28.053
!MESSAGE Unexpected interrupt while waiting on ECF browse request
!STACK 0
java.lang.InterruptedException
	at java.base/java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:45)
	at org.eclipse.core.internal.jobs.JobManager.join(JobManager.java:931)
	at org.eclipse.core.internal.jobs.InternalJob.join(InternalJob.java:344)
	at org.eclipse.core.runtime.jobs.Job.join(Job.java:531)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.waitOnSelf(FileInfoReader.java:74)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFiles(FileInfoReader.java:110)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getRemoteFile(FileInfoReader.java:125)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileInfoReader.getLastModified(FileInfoReader.java:130)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.getLastModified(RepositoryTransport.java:244)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.delegateGetLastModified(CachingTransport.java:404)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.getLastModified(CachingTransport.java:353)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.getLastModified(CacheManager.java:283)
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:231)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.getLocalFile(CompositeMetadataRepositoryFactory.java:77)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:100)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.epp.internal.mpc.ui.catalog.MarketplaceCatalog.lambda$12(MarketplaceCatalog.java:342)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:09:04.918
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:09:05.529
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:249)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.getLocalFile(SimpleMetadataRepositoryFactory.java:69)
	at org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory.load(SimpleMetadataRepositoryFactory.java:89)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.addChild(CompositeMetadataRepository.java:171)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository.<init>(CompositeMetadataRepository.java:113)
	at org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory.load(CompositeMetadataRepositoryFactory.java:124)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.factoryLoad(MetadataRepositoryManager.java:63)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Metadata.loadRepository(CachingRepositoryManager.java:518)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:110)
	at org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager.loadRepository(MetadataRepositoryManager.java:105)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.loadMetadataRepository(ProvisioningContext.java:233)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedMetadataRepositories(ProvisioningContext.java:211)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getMetadata(ProvisioningContext.java:299)
	at org.eclipse.equinox.internal.p2.director.SimplePlanner.updatesFor(SimplePlanner.java:1005)
	at org.eclipse.equinox.p2.operations.UpdateOperation.updatesFor(UpdateOperation.java:144)
	at org.eclipse.equinox.p2.operations.UpdateOperation.computeProfileChangeRequest(UpdateOperation.java:180)
	at org.eclipse.equinox.p2.operations.UpdateOperation.lambda$0(UpdateOperation.java:315)
	at org.eclipse.equinox.internal.p2.operations.SearchForUpdatesResolutionJob.runModal(SearchForUpdatesResolutionJob.java:41)
	at org.eclipse.equinox.p2.operations.ProfileChangeOperation.resolveModal(ProfileChangeOperation.java:118)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveModal(ProfileChangeOperationComputer.java:367)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolve(ProfileChangeOperationComputer.java:356)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.resolveUpdate(ProfileChangeOperationComputer.java:292)
	at org.eclipse.epp.internal.mpc.ui.operations.ProfileChangeOperationComputer.run(ProfileChangeOperationComputer.java:183)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Caused by: org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:09:05.530
!MESSAGE HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/content.xml
!STACK 1
org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:09:05.530
!MESSAGE General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:09:05.532
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:09:14.461
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/content.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:10:08.840
!MESSAGE Server returned lastModified <= 0 for https://raw.githubusercontent.com/PyvesB/eclipse-planet-themes/updatesite/artifacts.xml.xz

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:10:22.382
!MESSAGE Using unsafe http transport to retrieve http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.core 4 0 2023-08-17 13:10:22.984
!MESSAGE Provisioning exception
!STACK 1
org.eclipse.equinox.p2.core.ProvisionException: HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml
	at org.eclipse.equinox.internal.p2.repository.CacheManager.createCache(CacheManager.java:249)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory.getLocalFile(SimpleArtifactRepositoryFactory.java:68)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory.load(SimpleArtifactRepositoryFactory.java:92)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory.load(SimpleArtifactRepositoryFactory.java:80)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.load(CompositeArtifactRepository.java:496)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.addChild(CompositeArtifactRepository.java:177)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository.<init>(CompositeArtifactRepository.java:99)
	at org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory.load(CompositeArtifactRepositoryFactory.java:120)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.factoryLoad(ArtifactRepositoryManager.java:92)
	at org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager.loadRepository(AbstractRepositoryManager.java:787)
	at jdk.internal.reflect.GeneratedMethodAccessor55.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.oomph.util.ReflectUtil.invokeMethod(ReflectUtil.java:119)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:446)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager.loadRepository(CachingRepositoryManager.java:229)
	at org.eclipse.oomph.p2.internal.core.CachingRepositoryManager$Artifact.loadRepository(CachingRepositoryManager.java:585)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:131)
	at org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager.loadRepository(ArtifactRepositoryManager.java:125)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedRepository(ProvisioningContext.java:189)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getLoadedArtifactRepositories(ProvisioningContext.java:163)
	at org.eclipse.equinox.p2.engine.ProvisioningContext.getArtifactRepositories(ProvisioningContext.java:149)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.getArtifactRepositories(DownloadManager.java:110)
	at org.eclipse.equinox.internal.p2.engine.DownloadManager.start(DownloadManager.java:95)
	at org.eclipse.equinox.internal.p2.engine.phases.Collect.completePhase(Collect.java:111)
	at org.eclipse.equinox.internal.p2.engine.Phase.postPerform(Phase.java:254)
	at org.eclipse.equinox.internal.p2.engine.Phase.perform(Phase.java:105)
	at org.eclipse.equinox.internal.p2.engine.PhaseSet.perform(PhaseSet.java:50)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:80)
	at org.eclipse.equinox.internal.p2.engine.Engine.perform(Engine.java:48)
	at org.eclipse.equinox.p2.operations.ProvisioningSession.performProvisioningPlan(ProvisioningSession.java:181)
	at org.eclipse.equinox.p2.operations.ProfileModificationJob.runModal(ProfileModificationJob.java:76)
	at org.eclipse.equinox.p2.operations.ProvisioningJob.run(ProvisioningJob.java:188)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	... 1 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:10:22.984
!MESSAGE HTTP Server Unknown HTTP Response Code (308):http://dl.bintray.com/nodeclipse/nodeclipse/1.0.2f/artifacts.xml
!STACK 1
org.eclipse.ecf.filetransfer.BrowseFileTransferException: General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect
	at org.eclipse.ecf.provider.filetransfer.browse.URLFileSystemBrowser.runRequest(URLFileSystemBrowser.java:136)
	at org.eclipse.ecf.provider.filetransfer.browse.AbstractFileSystemBrowser$DirectoryJob.run(AbstractFileSystemBrowser.java:71)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:10:22.984
!MESSAGE General connection error with response code=308 and header(0)=HTTP/1.1 308 Permanent Redirect

!ENTRY org.eclipse.equinox.p2.repository 2 0 2023-08-17 13:10:22.985
!MESSAGE Using unsafe http transport to retrieve http://eclipse.jeeeyul.net/update/, see CVE-2021-41033. Consider using https instead.

!ENTRY org.eclipse.equinox.p2.artifact.repository 4 0 2023-08-17 13:10:26.587
!MESSAGE Error processing mirrors URL: http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.core.runtime.CoreException: HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:190)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	... 16 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:10:26.588
!MESSAGE HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:10:26.588
!MESSAGE General connection error with response code=301

!ENTRY org.eclipse.equinox.p2.artifact.repository 4 0 2023-08-17 13:10:26.950
!MESSAGE Error processing mirrors URL: http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.core.runtime.CoreException: HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:190)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	... 16 more
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2023-08-17 13:10:26.950
!MESSAGE HTTP Server Unknown HTTP Response Code (301):http://www.eclipse.org/downloads/download.php?file=/buildship/updates/e410/releases/3.x/3.1.7.v20230428-1602&format=xml&countryCode=us&timeZone=-3&format=xml
!STACK 1
org.eclipse.ecf.filetransfer.IncomingFileTransferException: General connection error with response code=301
	at org.eclipse.ecf.provider.filetransfer.retrieve.UrlConnectionRetrieveFileTransfer.openStreams(UrlConnectionRetrieveFileTransfer.java:340)
	at org.eclipse.ecf.provider.filetransfer.retrieve.AbstractRetrieveFileTransfer.sendRetrieveRequest(AbstractRetrieveFileTransfer.java:887)
	at org.eclipse.ecf.provider.filetransfer.retrieve.MultiProtocolRetrieveAdapter.sendRetrieveRequest(MultiProtocolRetrieveAdapter.java:148)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.sendRetrieveRequest(FileReader.java:456)
	at org.eclipse.equinox.internal.p2.transport.ecf.FileReader.read(FileReader.java:294)
	at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:181)
	at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:269)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorsDocument(MirrorSelector.java:294)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.computeMirrors(MirrorSelector.java:259)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.initMirrors(MirrorSelector.java:349)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.selectMirror(MirrorSelector.java:417)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector.getMirrorLocation(MirrorSelector.java:327)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getMirror(SimpleArtifactRepository.java:774)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.downloadArtifact(SimpleArtifactRepository.java:671)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:804)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.getArtifact(MirrorRequest.java:329)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transferSingle(MirrorRequest.java:299)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.transfer(MirrorRequest.java:232)
	at org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest.perform(MirrorRequest.java:162)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository.getArtifact(SimpleArtifactRepository.java:787)
	at org.eclipse.equinox.internal.p2.artifact.repository.simple.DownloadJob.run(DownloadJob.java:64)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.ecf.identity 4 0 2023-08-17 13:10:26.950
!MESSAGE General connection error with response code=301
